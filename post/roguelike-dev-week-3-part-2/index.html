<!doctype html>
<html lang="en-US">
  <head>
    


  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:; connect-src 'self' wss: data:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'">


    <meta name="generator" content="After Dark Hugo">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoguelikeDev Builds a Roguelike, Part 6 | Jeremy&#39;s Ramblings</title>
    <meta name="description" content="Part 6: Preparing for Combat">
    <meta name="keywords" content="RLDBAR, go, programming, roguelike, combat">
    
    
    
    
    <meta property="og:title" content="RoguelikeDev Builds a Roguelike, Part 6" />
<meta property="og:description" content="Part 6: Preparing for Combat" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeremyceri.se/post/roguelike-dev-week-3-part-2/" />
<meta property="og:image" content="https://source.unsplash.com/collection/983219/2000x1322"/>
<meta property="article:published_time" content="2017-07-23T22:20:22-06:00" />
<meta property="article:modified_time" content="2017-07-23T22:20:22-06:00" />

    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://source.unsplash.com/collection/983219/2000x1322"/>

<meta name="twitter:title" content="RoguelikeDev Builds a Roguelike, Part 6"/>
<meta name="twitter:description" content="Part 6: Preparing for Combat"/>

    



  <meta property="og:image" content="https://source.unsplash.com/collection/983219/2000x1322">


    

    
    
  <meta name="referrer" content="same-origin">


    
    
    <script integrity="sha512-2t0yyNrUdtn9WGIoBVxq5vtoJQYfoDQDbqRPpOb75f1hiL39DGLdJKDrGP60fBhXfrFeKyVhzWJvHvLgln/ElA==">/*! Fetch Inject v2.0.4 | Copyright (C) Josh Habdas <jhabdas@protonmail.com> (https://habd.as) | @license Zlib */
var fetchInject=function(){"use strict";const e=function(e,t,r,n,o,c,i){c=t.createElement(r),i=t.getElementsByTagName(r)[0],c.appendChild(t.createTextNode(n.text)),c.onload=o(n),i?i.parentNode.insertBefore(c,i):t.head.appendChild(c)};return function(t,r){if(!arguments.length)return Promise.reject(new ReferenceError("Failed to execute 'fetchInject': 1 argument required but only 0 present."));if(arguments[0]&&arguments[0].constructor!==Array)return Promise.reject(new TypeError("Failed to execute 'fetchInject': argument 1 must be of type 'Array'."));if(arguments[1]&&arguments[1].constructor!==Promise)return Promise.reject(new TypeError("Failed to execute 'fetchInject': argument 2 must be of type 'Promise'."));const n=[],o=r?[].concat(r):[],c=[];return t.forEach(e=>o.push(window.fetch(e).then(e=>[e.clone().text(),e.blob()]).then(e=>Promise.all(e).then(e=>{n.push({text:e[0],blob:e[1]})})))),Promise.all(o).then(()=>(n.forEach(t=>{c.push({then:r=>{t.blob.type.includes("text/css")?e(window,document,"style",t,r):e(window,document,"script",t,r)}})}),Promise.all(c)))}}();
</script>
    <script integrity="sha512-2XlvnxweZhaHgBdCoOK0PoCUWiSfKibb&#43;RCRZNgqLdvbnx0ZH67FDGKQqmpqCerjMJbZFv6fsXgbmJOOA9K&#43;qA==">/*!
 * Copyright (C) 2019  Josh Habdas <jhabdas@protonmail.com>
 *
 * This file is part of After Dark.
 *
 * After Dark is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * After Dark is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

fetchInject(["/js/lazysizes.min.js"]);
</script>
    


  
    

  <meta title="mod:fractal-forest" content="status:enabled">
  
    <script async src=/js/bpgdec8a.js integrity=sha384-8PG0go3BW8hLm63KbTxk/hNcehaoSbrAhKzsmy2Jhs/KY8QdiKKkjhdeyHY/Q/0I&#10;></script>
  


  
  
  
  


    
    <link rel="canonical" href="https://jeremyceri.se/post/roguelike-dev-week-3-part-2/">
    
    
    <link rel="icon" sizes="any" href="data:image/svg+xml,%3Csvg%20viewBox='0%200%2046%2045'%20xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EAfter%20Dark%3C/title%3E%3Cpath%20d='M.708%2045L23%20.416%2045.292%2045H.708zM35%2038L23%2019%2011%2038h24z'%20fill='%23000'/%3E%3C/svg%3E">

    

  
  
  
  
  
  
  
    
      
        <style>html{font-size:12px}*{box-sizing:border-box;text-rendering:geometricPrecision}body{font-size:1rem;line-height:1.5rem;margin:0;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.3em}fieldset{border:none;padding:0;margin:0}pre{padding:2rem;margin:1.75rem 0;background-color:#fff;border:1px solid #ccc;overflow:auto}code[class*=language-],pre[class*=language-],pre code{font-weight:100;text-shadow:none;margin:1.75rem 0}a{cursor:pointer;color:#ff2e88;text-decoration:none;border-bottom:1px solid #ff2e88}a:hover{background-color:#ff2e88;color:#fff}.grid{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.grid.\-top{-ms-flex-align:start;align-items:flex-start}.grid.\-middle{-ms-flex-align:center;align-items:center}.grid.\-bottom{-ms-flex-align:end;align-items:flex-end}.grid.\-stretch{-ms-flex-align:stretch;align-items:stretch}.grid.\-baseline{-ms-flex-align:baseline;align-items:baseline}.grid.\-left{-ms-flex-pack:start;justify-content:flex-start}.grid.\-center{-ms-flex-pack:center;justify-content:center}.grid.\-right{-ms-flex-pack:end;justify-content:flex-end}.grid.\-between{-ms-flex-pack:justify;justify-content:space-between}.grid.\-around{-ms-flex-pack:distribute;justify-content:space-around}.cell{-ms-flex:1;flex:1;box-sizing:border-box}@media screen and (min-width:768px){.cell.\-1of12{-ms-flex:0 0 8.33333%;flex:0 0 8.33333%}.cell.\-2of12{-ms-flex:0 0 16.66667%;flex:0 0 16.66667%}.cell.\-3of12{-ms-flex:0 0 25%;flex:0 0 25%}.cell.\-4of12{-ms-flex:0 0 33.33333%;flex:0 0 33.33333%}.cell.\-5of12{-ms-flex:0 0 41.66667%;flex:0 0 41.66667%}.cell.\-6of12{-ms-flex:0 0 50%;flex:0 0 50%}.cell.\-7of12{-ms-flex:0 0 58.33333%;flex:0 0 58.33333%}.cell.\-8of12{-ms-flex:0 0 66.66667%;flex:0 0 66.66667%}.cell.\-9of12{-ms-flex:0 0 75%;flex:0 0 75%}.cell.\-10of12{-ms-flex:0 0 83.33333%;flex:0 0 83.33333%}.cell.\-11of12{-ms-flex:0 0 91.66667%;flex:0 0 91.66667%}}@media screen and (max-width:768px){.grid{-ms-flex-direction:column;flex-direction:column}.cell{-ms-flex:0 0 auto;flex:0 0 auto}}.hack,.hack blockquote,.hack code,.hack em,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack strong{font-size:1rem;font-style:normal;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif}.hack blockquote,.hack code,.hack em,.hack strong{line-height:20px}.hack blockquote,.hack code,.hack footer,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack header,.hack li,.hack ol,.hack p,.hack section,.hack ul{float:none;margin:0;padding:0}.hack blockquote,.hack h1,.hack ol,.hack p,.hack ul{margin-top:20px;margin-bottom:20px}.hack h1{position:relative;display:inline-block;display:table-cell;padding:20px 0 30px;margin:0;overflow:hidden}.hack h1:after{content:"====================================================================================================";position:absolute;bottom:10px;left:0}.hack h1+*{margin-top:0}.hack h2,.hack h3,.hack h4,.hack h5,.hack h6{position:relative;margin-bottom:1.75rem}.hack h2:before,.hack h3:before,.hack h4:before,.hack h5:before,.hack h6:before{display:inline}.hack h2:before{content:"## "}.hack h3:before{content:"### "}.hack h4:before{content:"#### "}.hack h5:before{content:"##### "}.hack h6:before{content:"###### "}.hack li{position:relative;display:block;padding-left:20px}.hack li:after{position:absolute;top:0;left:0}.hack ul>li:after{content:"-"}.hack ol{counter-reset:a}.hack ol>li:after{content:counter(a) ".";counter-increment:a}.hack ol li:nth-child(n+10):after{left:-7px}.hack blockquote{position:relative;padding-left:17px;padding-left:2ch;overflow:hidden}.hack blockquote:after{content:">\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>";white-space:pre;position:absolute;top:0;left:0;line-height:20px}.hack em:after,.hack em:before{content:"*";display:inline}.hack pre code:after,.hack pre code:before{content:""}.hack code{font-weight:700}.hack code:after,.hack code:before{content:"`";display:inline}.hack hr{position:relative;height:20px;overflow:hidden;border:0;margin:20px 0}.hack hr:after{content:"----------------------------------------------------------------------------------------------------";position:absolute;top:0;left:0;line-height:20px;width:100%;word-wrap:break-word}@-moz-document url-prefix(){.hack h1{display:block}}.hack-ones ol>li:after{content:"1."}p{margin:0 0 1.75rem}.container{max-width:70rem}.container,.container-fluid{margin:0 auto;padding:0 1rem}.inner{padding:1rem}.inner2x{padding:2rem}.pull-left{float:left}.pull-right{float:right}.progress-bar{height:8px;opacity:.8;background-color:#ccc;margin-top:12px}.progress-bar.progress-bar-show-percent{margin-top:38px}.progress-bar-filled{background-color:gray;height:100%;transition:width .3s ease;position:relative;width:0}.progress-bar-filled:before{content:"";border:6px solid transparent;border-top-color:gray;position:absolute;top:-12px;right:-6px}.progress-bar-filled:after{color:gray;content:attr(data-filled);display:block;font-size:12px;white-space:nowrap;position:absolute;border:6px solid transparent;top:-38px;right:0;-ms-transform:translateX(50%);transform:translateX(50%)}table{width:100%;border-collapse:collapse;margin:1.75rem 0;color:#778087}table td,table th{vertical-align:top;border:1px solid #ccc;line-height:15px;padding:10px}table thead th{font-size:10px}table tbody td:first-child{font-weight:700;color:#333}.form{width:30rem}.form-group{margin-bottom:1.75rem;overflow:auto}.form-group label{border-bottom:2px solid #ccc;color:#333;width:10rem;display:inline-block;height:38px;line-height:38px;padding:0;float:left;position:relative}.form-group.form-success label{color:#4caf50!important;border-color:#4caf50!important}.form-group.form-warning label{color:#ff9800!important;border-color:#ff9800!important}.form-group.form-error label{color:#f44336!important;border-color:#f44336!important}.form-control{outline:none;border:none;border-bottom:2px solid #ccc;padding:.5rem 0;width:20rem;height:38px;background-color:transparent}.form-control:focus{border-color:#555}.form-group.form-textarea label:after{position:absolute;content:"";width:2px;background-color:#fff;right:-2px;top:0;bottom:0}textarea.form-control{height:auto;resize:none;padding:1rem 0;border-bottom:2px solid #ccc;border-left:2px solid #ccc;padding:.5rem}select.form-control{border-radius:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}.help-block{color:#999;margin-top:.5rem}.form-actions{margin-bottom:1.75rem}.btn{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;outline:none;padding:.65rem 2rem;font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;z-index:1}.btn:active{box-shadow:inset 0 1px 3px rgba(0,0,0,.12)}.btn.btn-ghost{border-color:#757575;color:#757575;background-color:transparent}.btn.btn-ghost:focus,.btn.btn-ghost:hover{border-color:#424242;color:#424242;z-index:2}.btn.btn-ghost:hover{background-color:transparent}.btn-block{width:100%;display:-ms-flexbox;display:flex}.btn-default{color:#fff;background-color:#e0e0e0;border:1px solid #e0e0e0;color:#333}.btn-default:focus:not(.btn-ghost),.btn-default:hover{background-color:#dcdcdc;border-color:#dcdcdc}.btn-success{color:#fff;background-color:#4caf50;border:1px solid #4caf50}.btn-success:focus:not(.btn-ghost),.btn-success:hover{background-color:#43a047;border-color:#43a047}.btn-success.btn-ghost{border-color:#4caf50;color:#4caf50}.btn-success.btn-ghost:focus,.btn-success.btn-ghost:hover{border-color:#388e3c;color:#388e3c;z-index:2}.btn-error{color:#fff;background-color:#f44336;border:1px solid #f44336}.btn-error:focus:not(.btn-ghost),.btn-error:hover{background-color:#e53935;border-color:#e53935}.btn-error.btn-ghost{border-color:#f44336;color:#f44336}.btn-error.btn-ghost:focus,.btn-error.btn-ghost:hover{border-color:#d32f2f;color:#d32f2f;z-index:2}.btn-warning{color:#fff;background-color:#ff9800;border:1px solid #ff9800}.btn-warning:focus:not(.btn-ghost),.btn-warning:hover{background-color:#fb8c00;border-color:#fb8c00}.btn-warning.btn-ghost{border-color:#ff9800;color:#ff9800}.btn-warning.btn-ghost:focus,.btn-warning.btn-ghost:hover{border-color:#f57c00;color:#f57c00;z-index:2}.btn-info{color:#fff;background-color:#00bcd4;border:1px solid #00bcd4}.btn-info:focus:not(.btn-ghost),.btn-info:hover{background-color:#00acc1;border-color:#00acc1}.btn-info.btn-ghost{border-color:#00bcd4;color:#00bcd4}.btn-info.btn-ghost:focus,.btn-info.btn-ghost:hover{border-color:#0097a7;color:#0097a7;z-index:2}.btn-primary{color:#fff;background-color:#2196f3;border:1px solid #2196f3}.btn-primary:focus:not(.btn-ghost),.btn-primary:hover{background-color:#1e88e5;border-color:#1e88e5}.btn-primary.btn-ghost{border-color:#2196f3;color:#2196f3}.btn-primary.btn-ghost:focus,.btn-primary.btn-ghost:hover{border-color:#1976d2;color:#1976d2;z-index:2}.btn-group{overflow:auto}.btn-group .btn{float:left}.btn-group .btn-ghost:not(:first-child){margin-left:-1px}.card{border:1px solid #ccc}.card .card-header{color:#333;text-align:center;background-color:#ddd;padding:.5rem 0}.alert{color:#ccc;padding:1rem;border:1px solid #ccc;margin-bottom:1.75rem}.alert-success{color:#4caf50;border-color:#4caf50}.alert-error{color:#f44336;border-color:#f44336}.alert-info{color:#00bcd4;border-color:#00bcd4}.alert-warning{color:#ff9800;border-color:#ff9800}.media:not(:last-child){margin-bottom:1.25rem}.media-left{padding-right:1rem}.media-left,.media-right{display:table-cell;vertical-align:top}.media-right{padding-left:1rem}.media-body{display:table-cell;vertical-align:top}.media-heading{font-size:1.16667rem;font-weight:700}.media-content{margin-top:.3rem}.avatarholder,.placeholder{background-color:#f0f0f0;text-align:center;color:#b9b9b9;font-size:1rem;border:1px solid #f0f0f0}.avatarholder{width:48px;height:48px;line-height:46px;font-size:2rem;background-size:cover;background-position:50%;background-repeat:no-repeat}.avatarholder.rounded{border-radius:33px}.loading{display:inline-block;content:"&nbsp;";height:20px;width:20px;margin:0 .5rem;animation:a .6s infinite linear;border:2px solid #e91e63;border-right-color:transparent;border-radius:50%}.btn .loading{margin-bottom:0;width:14px;height:14px}.btn div.loading{float:left}.alert .loading{margin-bottom:-5px}@keyframes a{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.menu{width:100%}.menu .menu-item{display:block;color:#616161;border-color:#616161}.menu .menu-item.active,.menu .menu-item:hover{color:#000;border-color:#000;background-color:transparent}@media screen and (max-width:768px){.form-group label{display:block;border-bottom:none;width:100%}.form-group.form-textarea label:after{display:none}.form-control{width:100%}textarea.form-control{border-left:none;padding:.5rem 0}pre::-webkit-scrollbar{height:3px}}@media screen and (max-width:480px){.form{width:100%}}.dark{color:#ccc}.dark,.dark pre{background-color:#000}.dark pre{padding:0;border:none}.dark pre code{color:#00bcd4}.dark h1 a,.dark h2 a,.dark h3 a,.dark h4 a,.dark h5 a{color:#ccc}.dark code,.dark strong{color:#fff}.dark code{font-weight:100}.dark table{color:#ccc}.dark table td,.dark table th{border-color:#444}.dark table tbody td:first-child{color:#fff}.dark .form-group label{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-group.form-textarea label:after{background-color:#000}.dark .form-control{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-control:focus{border-color:#ccc;color:#ccc}.dark textarea.form-control{color:#ccc}.dark .card{border-color:rgba(95,95,95,.78)}.dark .card .card-header{background-color:transparent;color:#ccc;border-bottom:1px solid rgba(95,95,95,.78)}.dark .btn.btn-ghost.btn-default{border-color:#ababab;color:#ababab}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#9c9c9c;color:#9c9c9c;z-index:1}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#e0e0e0;color:#e0e0e0}.dark .btn.btn-ghost.btn-primary:focus,.dark .btn.btn-ghost.btn-primary:hover{border-color:#64b5f6;color:#64b5f6}.dark .btn.btn-ghost.btn-success:focus,.dark .btn.btn-ghost.btn-success:hover{border-color:#81c784;color:#81c784}.dark .btn.btn-ghost.btn-info:focus,.dark .btn.btn-ghost.btn-info:hover{border-color:#4dd0e1;color:#4dd0e1}.dark .btn.btn-ghost.btn-error:focus,.dark .btn.btn-ghost.btn-error:hover{border-color:#e57373;color:#e57373}.dark .btn.btn-ghost.btn-warning:focus,.dark .btn.btn-ghost.btn-warning:hover{border-color:#ffb74d;color:#ffb74d}.dark .avatarholder,.dark .placeholder{background-color:transparent;border-color:#333}.dark .menu .menu-item{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .menu .menu-item.active,.dark .menu .menu-item:hover{color:#fff;border-color:#ccc}/*!* Copyright (C) 2019 Josh Habdas <jhabdas@protonmail.com>
*
* This file is part of After Dark.
*
* After Dark is free software: you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as published
* by the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* After Dark is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public License
* along with this program. If not, see <https://www.gnu.org/licenses/>.*/:root{scroll-behavior:smooth;--screen-size-small: 30em}@keyframes intro{0%{opacity:0}100%{opacity:1}}.blur-up.lazyloading{filter:blur(5px);opacity:1;transition:opacity 1s,filter 1.5s}.blur-up.lazyload{opacity:0;filter:blur(10px)}.blur-up.lazyloaded{filter:blur(0);transition:filter 1s}.hack .readmore{margin-bottom:2.2em}.responsive-iframe,.ratio-container{position:relative;padding-bottom:56.25%;padding-top:25px;height:0}.responsive-iframe iframe,.ratio-container>*:not([itemprop=caption]){position:absolute;top:0;left:0;width:100%;height:100%}iframe{border:0}main,footer{animation:intro .3s both;animation-delay:.15s}header:first-of-type+details{margin:20px 0}footer time[datetime$=M]:before{content:"\2013\0020"}body>footer p.muted{margin-bottom:0}@media only screen and (max-width:768px){footer time[datetime$=M]{display:none}}blockquote cite{display:block}blockquote cite::before{content:"\2014\00A0"}:target{filter:brightness(1.2)}:disabled{cursor:not-allowed}.hack li ul{margin:0}.hack ol li{padding-left:27px}.main{padding:20px 10px}input.form-control{border-radius:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}input.form-control,textarea.form-control,select.form-control,.help-block{font-size:initial}@media only screen and (max-width:768px){.help-block{font-size:unset}}html{font-size:13px}.hack .form input,.hack .form textarea,.hack .form button,.hack .form label{font-size:1rem}.hack .alert .highlight:first-of-type .chroma,.hack .card .highlight:first-of-type .chroma,.hack .alert pre:first-of-type,.hack .alert p:first-of-type,.hack .card pre:first-of-type,.hack .card p:first-of-type{margin-top:unset}.hack .alert .highlight:last-of-type .chroma,.hack .card .highlight:last-of-type .chroma,.hack .alert pre:last-of-type,.hack .alert p:last-of-type,.hack .card pre:last-of-type,.hack .card p:last-of-type{margin-bottom:unset}.hack blockquote,.hack blockquote:after{line-height:1.5}.hack figure,.standard figure{margin:unset}.hack figure a{border-bottom:none}.hack figure a:hover{background-color:inherit}article header img{width:100%;border-radius:3px}table td,table th{line-height:inherit}table a{border-bottom:unset}img{max-width:100%}@media only screen and (min-width:768px){html{font-size:16px}.container{max-width:50rem}}@media only screen and (min-width:768px),(-ms-high-contrast:active),(-ms-high-contrast:none){html{margin-left:calc(100vw - 100%)}}/*!
 * Copyright (C) 2019  Josh Habdas <jhabdas@protonmail.com>
 *
 * This file is part of After Dark.
 *
 * After Dark is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * After Dark is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

a[rel*="external"]::after {
  content: " " url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20class='i-external'%20viewBox='0%200%2032%2032'%20width='14'%20height='14'%20fill='none'%20stroke='%23ff9800'%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='9.38%'%3E%3Cpath%20d='M14%209%20L3%209%203%2029%2023%2029%2023%2018%20M18%204%20L28%204%2028%2014%20M28%204%20L14%2018'/%3E%3C/svg%3E");
}
nav a.active {
  background-color: inherit;
  color: #fff;
}
a[itemprop="url"] {
  color: #ff9800;
}
a[itemprop="url"]:hover {
  color: #fff;
}
.muted, .help-block {
  opacity: 0.70;
}
.hack .muted,
.hack .help-block {
  color: #e0e0e0;
}
</style>
        


  
    <meta name="theme-color" content=#000>
  


      
    
  


    
    
      <script integrity="sha512-ISTAV0GadOIz/NXXHOS+eCM0ysXVVHhQTlvA6LJxz/DeA5yIxm0Vqf5IE+WH0yuuXkayAKtoZkQ326nch5f/fg==">fetchInject(["/css/syntax.css"]);</script>
      <noscript>
        <link href="/css/syntax.css" rel="stylesheet">
      </noscript>
    
  </head>
  
  
  
  <body class="hack dark main container">
    <header>
  

  
    
      
      
  <nav itemscope itemtype="https://schema.org/SiteNavigationElement">
    <meta itemprop="name" content="Main Menu">
    
      
      
        <a itemprop="url" href="/">Home</a>
      
    
      
      
        <a itemprop="url" href="/about-me/">About</a>
      
    
      
      
        <a itemprop="url" class="active" href="/post/">Posts</a>
      
    
      
      
        <a itemprop="url" href="/roguelikes/">Roguelike Development</a>
      
    
  </nav>


    
  


</header>
    <main>
  
    
      <style>{{ -}}.hack header figure[itemtype*=ImageObject]{position:relative}.hack header figure[itemtype*=ImageObject] figcaption{position:absolute;bottom:0;right:0;text-align:right;padding:15px;font-style:oblique;font-size:smaller;mix-blend-mode:soft-light}.hack header figure[itemtype*=ImageObject] [itemprop=headline]{font-weight:700}</style>
    
  
  <article itemscope itemtype="https://schema.org/BlogPosting">
    <meta itemprop="name" content="RoguelikeDev Builds a Roguelike, Part 6">
<meta itemprop="description" content="Part 6: Preparing for Combat">
<meta itemprop="datePublished" content="2017-07-23T22:20:22-06:00" />
<meta itemprop="dateModified" content="2017-07-23T22:20:22-06:00" />
<meta itemprop="wordCount" content="2660">
<meta itemprop="image" content="https://source.unsplash.com/collection/983219/2000x1322"/>



<meta itemprop="keywords" content="RLDBAR,go,programming,roguelike,combat," />
    <header>
      <h1 itemprop="headline name">RoguelikeDev Builds a Roguelike, Part 6</h1>
      <p class="muted">
        <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <circle cx="16" cy="16" r="14" />
  <path d="M16 8 L16 16 20 20" />
</svg>
<span>13 minute read</span>
<svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z" />
</svg>

  Published: <time datetime="2017-07-23T22:20:22-06:00">23 Jul, 2017</time>


      </p>
      
        <blockquote itemprop="description">Part 6: Preparing for Combat</blockquote>
      
      



    </header>
    

    <div itemprop="articleBody">
      <p>Welcome back to my series about building a Roguelike in Go (and following along with RoguelikeDev&rsquo;s dev-along)! Last time, we added a field of vision algorithm to our game, putting the player in the dark, except the immediate area surrounding them. In this installment, we&rsquo;re going to start adding the framework for monsters that inhabit the dark corners of the caverns. In particular, our goal will be to randomly place Game Entities, representing things such as Goblins, Troll, and Orcs, around our generated caverns, make sure they get to take actions, and allow the player to interact with them. We&rsquo;ll be adding proper combat in a later post, but for now, lets add some monsters!</p>
<!-- more -->
<p>A pertinent question that we should ask, before we dive in, is how are we going to represent the monsters that will inhabit the depths of our caverns? You may recall that we have a struct for just such a thing: GameEntity. Our GameEntity struct is exactly what we need to create monsters. GameEntity&rsquo;s sole purpose is to represent &lsquo;things&rsquo; in the game world, whether that be items, chests, NPCs, monsters, or the player. So far, we&rsquo;ve only used the GameEntity struct to represent our player (and a short lived NPC), but now we&rsquo;re going to start leveraging it much, much more.</p>
<p>We need to do some small additions to our GameEntity struct before we move forward. We&rsquo;re going to add a name property, as well as property that indicates whether this entity blocks movement (in the exact same way that a Tile does):</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GameEntity</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span> <span class="kt">int</span>
	<span class="nx">Y</span> <span class="kt">int</span>
	<span class="nx">Layer</span> <span class="kt">int</span>
	<span class="nx">Char</span> <span class="kt">string</span>
	<span class="nx">Color</span> <span class="kt">string</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Blocks</span> <span class="kt">bool</span>
<span class="p">}</span></code></pre></div>
<p>Nothing fancy there, just a string and a bool.</p>
<p>Now that we have that additional data attached to our entities, lets put some thought into how we want to go about creating new monster entities, and adding them to our game world. The easiest approach to this, and the one we&rsquo;re going to stick with for the time being, is to just randomly place some created entities around the map. There are a few challenges with this approach however: 1) We don&rsquo;t want to place entities outside the bounds of where the player can go, and 2) we don&rsquo;t want to place entities on top of one another. Lets setup the solution for the second issue first.</p>
<p>What we need is a way to see if there is a blocking entity at a given location. The way this should work is that, whenever we go to place an entity on our map, we will feed the intended coordinates into a function that checks the location of every entity currently placed, and make sure that one of them is not present at the location we are trying to use. This should be pretty easy to do, as we are also going to be keeping a (more or less) global list of entities that are present on the map. A logical place for this code to live in our entity package. This new function doesn&rsquo;t need to be attached to the GameEntity struct, but from an organizational standpoint, it makes sense to put it in the same file:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetBlockingEntitiesAtLocation</span><span class="p">(</span><span class="nx">entities</span> <span class="p">[]</span><span class="o">*</span><span class="nx">GameEntity</span><span class="p">,</span> <span class="nx">destinationX</span><span class="p">,</span> <span class="nx">destinationY</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">GameEntity</span> <span class="p">{</span>
	<span class="c1">// Return any entities that are at the destination location which would block movement
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">entities</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Blocks</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">X</span> <span class="o">==</span> <span class="nx">destinationX</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Y</span> <span class="o">==</span> <span class="nx">destinationY</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">e</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></div>
<p>We pass in a slice containing every entity currently present on the map, and the intended (x, y) coordinates for our new entity. We then check to see if there is an entity present, and if it blocks. If it does, we simply return that entity, or nil if nothing is present at the desired location.</p>
<p>Alright, we&rsquo;ve now got a way to check valid entity locations, lets set about actually creating and placing a bunch of monster entities on our map!</p>
<p>At this point, I&rsquo;ve decided to refactor my previous code a bit. We&rsquo;re going to be dealing with map related functions (generating and placing monsters based on the type of map), so it makes sense that the monster generation and placement code lives in the gamemap package. Previously, I had one file, gamemap.go, which contained all the map logic. I decided, to keep things tidy, to break the gamemap.go file into three files: gamemap.go, which contains the core, common map logic; arena.go, which contains all code related to arena maps; and cavern.go, which contains all logic specific to caverns. You can look <a href="https://github.com/jcerise/roguelikedev-does-the-complete-roguelike-tutorial/tree/master/src/gamemap">here</a> to see the specifics of how this is now laid out. This is strictly an organizational change, so don&rsquo;t feel obligated to follow my lead, if you don&rsquo;t want to.</p>
<p>Anyways&hellip;</p>
<p>We&rsquo;re going to add a new function that will generate and place monsters in our cavern maps (I&rsquo;m ignoring arenas, since that&rsquo;s more for testing at the moment). Since we&rsquo;re dealing with cavern maps, I&rsquo;ve decided to call my function &lsquo;populateCavern&rsquo;. Lets look at the code, and I&rsquo;ll explain it afterwards:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">populateCavern</span><span class="p">(</span><span class="nx">mainCave</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Tile</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span> <span class="p">{</span>
	<span class="c1">// Randomly sprinkle some Orcs, Trolls, and Goblins around the newly created cavern
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">entities</span> <span class="p">[]</span><span class="o">*</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span>
	<span class="kd">var</span> <span class="nx">createdEntity</span> <span class="o">*</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="nx">locationFound</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="c1">// Attempt to find a clear location to create a mob (entity for now)
</span><span class="c1"></span>			<span class="nx">pos</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">()</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mainCave</span><span class="p">)</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">mainCave</span><span class="p">[</span><span class="nx">pos</span><span class="p">].</span><span class="nx">X</span>
			<span class="nx">y</span> <span class="p">=</span> <span class="nx">mainCave</span><span class="p">[</span><span class="nx">pos</span><span class="p">].</span><span class="nx">Y</span>
			<span class="k">if</span> <span class="nx">entity</span><span class="p">.</span><span class="nf">GetBlockingEntitiesAtLocation</span><span class="p">(</span><span class="nx">entities</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">locationFound</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">locationFound</span> <span class="p">{</span>
			<span class="nx">chance</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">chance</span> <span class="o">&lt;=</span> <span class="mi">25</span> <span class="p">{</span>
				<span class="c1">// Create a Troll
</span><span class="c1"></span>				<span class="nx">createdEntity</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">Layer</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Char</span><span class="p">:</span> <span class="s">&#34;T&#34;</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="s">&#34;dark green&#34;</span><span class="p">,</span> <span class="nx">Blocks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Troll&#34;</span><span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">chance</span> <span class="p">&gt;</span> <span class="mi">25</span> <span class="o">&amp;&amp;</span> <span class="nx">chance</span> <span class="o">&lt;=</span> <span class="mi">50</span> <span class="p">{</span>
				<span class="c1">// Create an Orc
</span><span class="c1"></span>				<span class="nx">createdEntity</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">Layer</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Char</span><span class="p">:</span> <span class="s">&#34;o&#34;</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="s">&#34;darker green&#34;</span><span class="p">,</span> <span class="nx">Blocks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Orc&#34;</span><span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// Create a Goblin
</span><span class="c1"></span>				<span class="nx">createdEntity</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">Y</span><span class="p">:</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">Layer</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">Char</span><span class="p">:</span> <span class="s">&#34;g&#34;</span><span class="p">,</span> <span class="nx">Color</span><span class="p">:</span> <span class="s">&#34;green&#34;</span><span class="p">,</span> <span class="nx">Blocks</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Goblin&#34;</span><span class="p">}</span>
			<span class="p">}</span>

			<span class="nx">entities</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">entities</span><span class="p">,</span> <span class="nx">createdEntity</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// No location was found after 50 tries, which means the map is quite full. Stop here and return.
</span><span class="c1"></span>			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">entities</span>
<span class="p">}</span></code></pre></div>
<p>populateCavern() takes a list of Tiles called mainCave. You may remember from the post on map generation that our cavern generation algorithm keeps track of the main cave area used during the final steps of the process. We&rsquo;re going to pass that slice into our populateCavern() function, as it contains a list of all clear, non-wall Tiles in the playable area, which is exactly what we need.</p>
<p>We start off by creating a for loop. This outer loop will determine how many monsters we generate. I&rsquo;ve set mine to 2, but you can tweak that value to your liking. Next, we step into an inner loop, that runs no more than 50 times. This loop is going to attempt to find a valid, clear location for our new (yet to be created) monster. The reason for this loop is simple: we are going to randomly generate coordinates within our cavern, and then check if it is a clear (no blocking entity present) location. If it is not, we will iterate, and try again, with a new set of random coordinates. We will keep looping and looking until a valid location is found. If the loop runs for more than 50 iterations, its pretty safe to assume that there are no valid locations left, and the loop should break. This will prevent our game from endlessly looking for a valid location, when one may not even exist.</p>
<p>The location checker loop is pretty straight forward. We grab a random position within the mainCave, and get the (X, Y) values from the Tile at that location. We then use our new GetBlockingEntitiesAtLocation() function, passing in the randomly generated (x, y) coordinates. If that function returns nil, we have found a valid location, and we set the locationFound variable to true, and break out of the loop. If no valid location is found, we try again. If all 50 iterations are used up, the loop will end, with locationFound still having a value of false.</p>
<p>Next, if a location was in fact found, we generate a random number between 1 and 100. This will give us a 25% chance of creating a Troll, a 25% chance of creating an Orc, and a 50% chance of creating a Goblin. We then create the appropriate entity, using our new name and blocks properties.</p>
<p>Finally, we append the newly created entity onto the local entities slice, which will be returned.</p>
<p>We&rsquo;ve now got some entities, in valid locations, for our map. Lets quickly look at the code in GenerateCavern() that calls this new function:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">GenerateCavern</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="p">[]</span><span class="o">*</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>

  <span class="c1">// Populate the cavern with some nasty critters
</span><span class="c1"></span>	<span class="nx">entities</span> <span class="o">:=</span> <span class="nf">populateCavern</span><span class="p">(</span><span class="nx">mainCave</span><span class="p">)</span>

	<span class="c1">// Finally, choose a starting position for the player within the newly created cave
</span><span class="c1"></span>	<span class="nx">pos</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">()</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mainCave</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">mainCave</span><span class="p">[</span><span class="nx">pos</span><span class="p">].</span><span class="nx">X</span><span class="p">,</span> <span class="nx">mainCave</span><span class="p">[</span><span class="nx">pos</span><span class="p">].</span><span class="nx">Y</span><span class="p">,</span> <span class="nx">entities</span>
<span class="p">}</span></code></pre></div>
<p>You can see I&rsquo;ve changed the signature a bit, as GenerateCavern() now returns a slice of GameEntity, alongside the valid coordinates for the player. Beyond that, we simply call the populateCavern() function, and assign the slice of returned entities to the &lsquo;entities&rsquo; variable, and then return that alongside the players (x, y) position.</p>
<p>Finally, lets get those entities drawn to the screen! Back in our main file, in our init() function, we&rsquo;re going to add a small update:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">...</span>

  <span class="nx">playerX</span><span class="p">,</span> <span class="nx">playerY</span><span class="p">,</span> <span class="nx">mapEntities</span> <span class="o">:=</span> <span class="nx">gameMap</span><span class="p">.</span><span class="nf">GenerateCavern</span><span class="p">()</span>
	<span class="nx">player</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">playerX</span>
	<span class="nx">player</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">playerY</span>

	<span class="nx">entities</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">entities</span><span class="p">,</span> <span class="nx">mapEntities</span><span class="o">...</span><span class="p">)</span>

  <span class="o">...</span>
<span class="p">}</span></code></pre></div>
<p>We&rsquo;re now grabbing the returned GameEntity slice from our GenerateCavern() function. Earlier, we created a slice called entities (of which our player is a part) that was intended to contain every entity currently on the map. Here, we are simply appending the mapEntities slice to the (sort of) global entities slice. This will ensure that our entities from our map generation get drawn correctly, along side our player, each turn!</p>
<p><img src="/static/week-3-part-2-monsters-dumb.png" alt="Monsters on the map"></p>
<p>(You may notice that there is console output on my game. This is the topic of an upcoming SideNote, so stay tuned if that interests you.)</p>
<p>We&rsquo;ve successfully generated, placed, and drawn several (not yet) threatening monsters onto our game map. But&hellip;they don&rsquo;t really do much, and if the player attempts to interact with them, you&rsquo;ll find you can walk right through them as if they&rsquo;re not even there. These are some cut-rate monsters&hellip; Lets fix that!</p>
<p>As it stands right now, the player takes an action (currently only moving is implemented), and then is allowed to take another action, and another, and another, ad nauseum. We need a way to let the monsters take a turn, after the player has done something. Essentially, we are going to consider one action by the player to be his turn. So, the player moving north one Tile, or the player drinking a potion, or resting, these are all actions that would end the players turn. Once the player has acted, we want to let the monsters on the map do something as well. We&rsquo;re going to need some way of keeping track of the current turn, or game state.</p>
<p>Lets do that first. We&rsquo;ll create a couple of new constants, one called PlayerTurn, and one called MobTurn. What we&rsquo;re aiming for is basically an enum that we can reference to check or set the current state of the game, the players turn, or the monsters turn. Since Go doesn&rsquo;t have direct support for an enum type, I&rsquo;m going to use a language feature called &lsquo;iota&rsquo;. The iota keyword will auto-increment its value each time we call it, meaning that if we call it three times in sequence, each call will have a value of (1 + last_iota_value). This is super handy for creating enum like variable sets:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">WindowSizeX</span> <span class="p">=</span> <span class="mi">100</span>
	<span class="nx">WindowSizeY</span> <span class="p">=</span> <span class="mi">35</span>
	<span class="nx">MapWidth</span> <span class="p">=</span> <span class="mi">100</span>
	<span class="nx">MapHeight</span> <span class="p">=</span> <span class="mi">35</span>
	<span class="nx">Title</span> <span class="p">=</span> <span class="s">&#34;BearRogue&#34;</span>
	<span class="nx">Font</span> <span class="p">=</span> <span class="s">&#34;fonts/UbuntuMono.ttf&#34;</span>
	<span class="nx">FontSize</span> <span class="p">=</span> <span class="mi">24</span>
	<span class="nx">PlayerTurn</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">MobTurn</span> <span class="p">=</span> <span class="kc">iota</span>
<span class="p">)</span></code></pre></div>
<p>Now, I&rsquo;m going to set a new variable called gameTurn:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">player</span> <span class="o">*</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span>
	<span class="nx">entities</span> <span class="p">[]</span><span class="o">*</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span>
	<span class="nx">gameMap</span> <span class="o">*</span><span class="nx">gamemap</span><span class="p">.</span><span class="nx">Map</span>
	<span class="nx">gameCamera</span> <span class="o">*</span><span class="nx">camera</span><span class="p">.</span><span class="nx">GameCamera</span>
	<span class="nx">fieldOfView</span> <span class="o">*</span><span class="nx">fov</span><span class="p">.</span><span class="nx">FieldOfVision</span>
	<span class="nx">gameTurn</span> <span class="kt">int</span>
<span class="p">)</span></code></pre></div>
<p>Finally, in our init() function, we&rsquo;re going to set the gameTurn to the player:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>

    <span class="o">...</span>

    <span class="c1">// Set the current turn to the player, so they may act first
</span><span class="c1"></span>	<span class="nx">gameTurn</span> <span class="p">=</span> <span class="nx">PlayerTurn</span>

    <span class="o">...</span>
<span class="p">}</span></code></pre></div>
<p>The gameTurn variable will regularly get flipped from state to state. Once the player takes an action, it flips to MobTurn, and the monsters all get to take one action. Once they are done, it will flip back to PlayerTurn, etc. This sets up a nice turn by turn flow for the game, with every entity getting one action per turn.</p>
<p>Now, in our main game loop, we need to implement that logic. Turns out, its pretty simple:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>

    <span class="k">if</span> <span class="nx">key</span> <span class="o">!=</span> <span class="nx">blt</span><span class="p">.</span><span class="nx">TK_CLOSE</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">gameTurn</span> <span class="o">==</span> <span class="nx">PlayerTurn</span> <span class="p">{</span>
				<span class="nf">handleInput</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">player</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">gameTurn</span> <span class="o">==</span> <span class="nx">MobTurn</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">entities</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">e</span> <span class="o">!=</span> <span class="nx">player</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">gameMap</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">e</span><span class="p">.</span><span class="nx">X</span><span class="p">][</span><span class="nx">e</span><span class="p">.</span><span class="nx">Y</span><span class="p">].</span><span class="nx">Visible</span> <span class="p">{</span>
						<span class="c1">// Check to ensure that the entity is visible before allowing it to message the player
</span><span class="c1"></span>						<span class="c1">// This will change soon, as entities will act whether the player can see them or not.
</span><span class="c1"></span>						<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;The %s waits patiently...&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">gameTurn</span> <span class="p">=</span> <span class="nx">PlayerTurn</span>
		<span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span></code></pre></div>
<p>When we check for player input, we also check to see if it is in fact the players turn. If it is, we allow the input to be processed. If not, we skip over the action and continue. If it is the players turn, we call handleInput as normal, but there&rsquo;s one small change in there:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleInput</span><span class="p">(</span><span class="nx">key</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">player</span> <span class="o">*</span><span class="nx">entity</span><span class="p">.</span><span class="nx">GameEntity</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>

    <span class="c1">// Check to ensure that the tile the player is trying to move in to is a valid move (not blocked)
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">gameMap</span><span class="p">.</span><span class="nf">IsBlocked</span><span class="p">(</span><span class="nx">player</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">player</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">target</span> <span class="o">:=</span> <span class="nx">entity</span><span class="p">.</span><span class="nf">GetBlockingEntitiesAtLocation</span><span class="p">(</span><span class="nx">entities</span><span class="p">,</span> <span class="nx">player</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">dx</span><span class="p">,</span> <span class="nx">player</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="nx">dy</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">target</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;You harmlessly bump into the %s&#34;</span><span class="p">,</span> <span class="nx">target</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">player</span><span class="p">.</span><span class="nf">Move</span><span class="p">(</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Switch the game turn to the Mobs turn
</span><span class="c1"></span>	<span class="nx">gameTurn</span> <span class="p">=</span> <span class="nx">MobTurn</span>
<span class="p">}</span></code></pre></div>
<p>After we check if the desired location is blocked, we also check to see if there is a blocking entity present. If there is, we stop the movement, similar to how we stop movement into a wall, and print a message letting the player know that they have bumped into something nasty. Finally, we switch the game turn to the monsters.</p>
<p>Back in the main game loop, we check if its the monsters turn. If it is, we loop (naively right now, we&rsquo;ll make this better later) through every entity on the map, being sure to skip the player, and let them take an action. Right now that action consists of printing out that its waiting patiently, but later this will be things like moving, attacking, etc.</p>
<p>And that&rsquo;s it! If you fire up the game now, you should be able to find some monsters, which should act in reaction to your movement, and allow you to harmlessly bump into them.</p>
<p>This has laid the groundwork for our upcoming combat system. We&rsquo;ve allowed the player to interact with other entities, a theme we&rsquo;re going to continue to develop, as its one of the core mechanics of the game. We also set up a system to randomly fill our caves and dungeons with all sorts of nasty creatures, just waiting to hassle the player.</p>
<p>As usual, if you want to see the code for this post, you can find it <a href="https://github.com/jcerise/roguelikedev-does-the-complete-roguelike-tutorial/releases/tag/v0.0.7">here</a>. Next time, we&rsquo;ll be fleshing out the combat system, and adding some nice GUI components. Until then, happy developing!</p>
<p><a href="/post/roguelike-dev-part-7/">This way to Part 7: ECS Refactor</a></p>

    </div>
    <footer>
      <hr>
      <p>
  Published
  
    
      by <span itemprop="author">Jeremy Cerise</span>
    
  
  <time itemprop="datePublished" datetime="2017-07-23T22:20:22-06:00">
    23 Jul, 2017
  </time>
  
    in <span itemprop="articleSection"><a href="/categories/technology/">technology</a></span>
  
  
    and tagged <a rel="tag" href="/tags/combat/">combat</a>, <a rel="tag" href="/tags/go/">go</a>, <a rel="tag" href="/tags/programming/">programming</a>, <a rel="tag" href="/tags/rldbar/">RLDBAR</a> and <a rel="tag" href="/tags/roguelike/">roguelike</a>
  
  using <span itemprop="wordCount">2660</span> words.
</p>

      



  
    <aside>
      <header>Related Content</header>
      
        <ul>
          
            <li><a href="/post/roguelike-dev-week-3-part-1/">RoguelikeDev Builds a Roguelike, Part 5</a>
            <time class="muted" datetime="12M">12 minutes</time>
          
            <li><a href="/post/roguelike-dev-week-2/">RoguelikeDev Builds a Roguelike, Part 4</a>
            <time class="muted" datetime="18M">18 minutes</time>
          
            <li><a href="/post/sidenote-1-cameras/">RLDBAR Sidenote #1: Cameras</a>
            <time class="muted" datetime="9M">9 minutes</time>
          
            <li><a href="/post/roguelike-dev-week-1-part-2/">RoguelikeDev Builds A Roguelike, Part 3</a>
            <time class="muted" datetime="18M">18 minutes</time>
          
            <li><a href="/post/roguelike-dev-week-1-part-1/">RoguelikeDev Builds a Roguelike, Part 2</a>
            <time class="muted" datetime="8M">8 minutes</time>
          
            <li><a href="/post/roguelike-dev-week-0/">RoguelikeDev Builds a Roguelike, Part 1</a>
            <time class="muted" datetime="7M">7 minutes</time>
          
        </ul>
      
    </aside>
  


    </footer>
  </article>
</main>
    <footer>
  <small class="muted">
    
  
    Copyright &copy; Copyright Jermey Cerise. Licensed under <a target="_blank" rel="external noopener license" href="https://creativecommons.org/licenses/by-nd/4.0/">CC-BY-ND-4.0</a>.
  


  </small>
</footer>
    
    
    
      
    
  </body>
</html>
