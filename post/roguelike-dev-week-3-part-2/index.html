<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta name="generator" content="Hugo 0.40.2" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoguelikeDev Builds a Roguelike, Part 6 | Jeremy&#39;s Ramblings</title>
    <meta name="description" content="Part 6: Preparing for Combat">
    <meta name="keywords" content="RLDBAR, go, programming, roguelike, combat">
    
    
    
    
    

  <meta name="author" content="Jeremy Cerise">


    <meta property="og:title" content="RoguelikeDev Builds a Roguelike, Part 6" />
<meta property="og:description" content="Part 6: Preparing for Combat" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://jeremyceri.se/post/roguelike-dev-week-3-part-2/" />



<meta property="article:published_time" content="2017-07-23T22:20:22-06:00"/>

<meta property="article:modified_time" content="2017-07-23T22:20:22-06:00"/>











    



  <meta property="og:image" content="https://source.unsplash.com/category/technology/1600x900">


    <meta name="theme-color" content="#000">

    
    
    
    <link rel="canonical" href="http://jeremyceri.se/post/roguelike-dev-week-3-part-2/">
    
    
    <link rel="icon" sizes="any" href="data:image/svg+xml,%3Csvg%20viewBox='0%200%2046%2045'%20xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EAfter%20Dark%3C/title%3E%3Cpath%20d='M.708%2045L23%20.416%2045.292%2045H.708zM35%2038L23%2019%2011%2038h24z'%20fill='%23000'/%3E%3C/svg%3E">

    <style>
      html{font-size:12px}*{box-sizing:border-box;text-rendering:geometricPrecision}body{font-size:1rem;line-height:1.5rem;margin:0;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.3em}fieldset{border:none;padding:0;margin:0}pre{padding:2rem;margin:1.75rem 0;background-color:#fff;border:1px solid #ccc;overflow:auto}code[class*=language-],pre[class*=language-],pre code{font-weight:100;text-shadow:none;margin:1.75rem 0}a{cursor:pointer;color:#ff2e88;text-decoration:none;border-bottom:1px solid #ff2e88}a:hover{background-color:#ff2e88;color:#fff}.grid{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.grid.\-top{-ms-flex-align:start;-ms-grid-row-align:flex-start;align-items:flex-start}.grid.\-middle{-ms-flex-align:center;-ms-grid-row-align:center;align-items:center}.grid.\-bottom{-ms-flex-align:end;-ms-grid-row-align:flex-end;align-items:flex-end}.grid.\-stretch{-ms-flex-align:stretch;-ms-grid-row-align:stretch;align-items:stretch}.grid.\-baseline{-ms-flex-align:baseline;-ms-grid-row-align:baseline;align-items:baseline}.grid.\-left{-ms-flex-pack:start;justify-content:flex-start}.grid.\-center{-ms-flex-pack:center;justify-content:center}.grid.\-right{-ms-flex-pack:end;justify-content:flex-end}.grid.\-between{-ms-flex-pack:justify;justify-content:space-between}.grid.\-around{-ms-flex-pack:distribute;justify-content:space-around}.cell{-ms-flex:1;flex:1;box-sizing:border-box}@media screen and (min-width:768px){.cell.\-1of12{-ms-flex:0 0 8.33333%;flex:0 0 8.33333%}.cell.\-2of12{-ms-flex:0 0 16.66667%;flex:0 0 16.66667%}.cell.\-3of12{-ms-flex:0 0 25%;flex:0 0 25%}.cell.\-4of12{-ms-flex:0 0 33.33333%;flex:0 0 33.33333%}.cell.\-5of12{-ms-flex:0 0 41.66667%;flex:0 0 41.66667%}.cell.\-6of12{-ms-flex:0 0 50%;flex:0 0 50%}.cell.\-7of12{-ms-flex:0 0 58.33333%;flex:0 0 58.33333%}.cell.\-8of12{-ms-flex:0 0 66.66667%;flex:0 0 66.66667%}.cell.\-9of12{-ms-flex:0 0 75%;flex:0 0 75%}.cell.\-10of12{-ms-flex:0 0 83.33333%;flex:0 0 83.33333%}.cell.\-11of12{-ms-flex:0 0 91.66667%;flex:0 0 91.66667%}}@media screen and (max-width:768px){.grid{-ms-flex-direction:column;flex-direction:column}.cell{-ms-flex:0 0 auto;flex:0 0 auto}}.hack,.hack blockquote,.hack code,.hack em,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack strong{font-size:1rem;font-style:normal;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif}.hack blockquote,.hack code,.hack em,.hack strong{line-height:20px}.hack blockquote,.hack code,.hack footer,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack header,.hack li,.hack ol,.hack p,.hack section,.hack ul{float:none;margin:0;padding:0}.hack blockquote,.hack h1,.hack ol,.hack p,.hack ul{margin-top:20px;margin-bottom:20px}.hack h1{position:relative;display:inline-block;display:table-cell;padding:20px 0 30px;margin:0;overflow:hidden}.hack h1:after{content:"====================================================================================================";position:absolute;bottom:10px;left:0}.hack h1+*{margin-top:0}.hack h2,.hack h3,.hack h4,.hack h5,.hack h6{position:relative;margin-bottom:1.75rem}.hack h2:before,.hack h3:before,.hack h4:before,.hack h5:before,.hack h6:before{display:inline}.hack h2:before{content:"## "}.hack h3:before{content:"### "}.hack h4:before{content:"#### "}.hack h5:before{content:"##### "}.hack h6:before{content:"###### "}.hack li{position:relative;display:block;padding-left:20px}.hack li:after{position:absolute;top:0;left:0}.hack ul>li:after{content:"-"}.hack ol{counter-reset:a}.hack ol>li:after{content:counter(a) ".";counter-increment:a}.hack blockquote{position:relative;padding-left:17px;padding-left:2ch;overflow:hidden}.hack blockquote:after{content:">\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>";white-space:pre;position:absolute;top:0;left:0;line-height:20px}.hack em:after,.hack em:before{content:"*";display:inline}.hack pre code:after,.hack pre code:before{content:''}.hack code{font-weight:700}.hack code:after,.hack code:before{content:"`";display:inline}.hack hr{position:relative;height:20px;overflow:hidden;border:0;margin:20px 0}.hack hr:after{content:"----------------------------------------------------------------------------------------------------";position:absolute;top:0;left:0;line-height:20px;width:100%;word-wrap:break-word}@-moz-document url-prefix(){.hack h1{display:block}}.hack-ones ol>li:after{content:"1."}p{margin:0 0 1.75rem}.container{max-width:70rem}.container,.container-fluid{margin:0 auto;padding:0 1rem}.inner{padding:1rem}.inner2x{padding:2rem}.pull-left{float:left}.pull-right{float:right}.progress-bar{height:8px;opacity:.8;background-color:#ccc;margin-top:12px}.progress-bar.progress-bar-show-percent{margin-top:38px}.progress-bar-filled{background-color:gray;height:100%;transition:width .3s ease;position:relative;width:0}.progress-bar-filled:before{content:'';border:6px solid transparent;border-top-color:gray;position:absolute;top:-12px;right:-6px}.progress-bar-filled:after{color:gray;content:attr(data-filled);display:block;font-size:12px;white-space:nowrap;position:absolute;border:6px solid transparent;top:-38px;right:0;-ms-transform:translateX(50%);transform:translateX(50%)}table{width:100%;border-collapse:collapse;margin:1.75rem 0;color:#778087}table td,table th{vertical-align:top;border:1px solid #ccc;line-height:15px;padding:10px}table thead th{font-size:10px}table tbody td:first-child{font-weight:700;color:#333}.form{width:30rem}.form-group{margin-bottom:1.75rem;overflow:auto}.form-group label{border-bottom:2px solid #ccc;color:#333;width:10rem;display:inline-block;height:38px;line-height:38px;padding:0;float:left;position:relative}.form-group.form-success label{color:#4caf50!important;border-color:#4caf50!important}.form-group.form-warning label{color:#ff9800!important;border-color:#ff9800!important}.form-group.form-error label{color:#f44336!important;border-color:#f44336!important}.form-control{outline:none;border:none;border-bottom:2px solid #ccc;padding:.5rem 0;width:20rem;height:38px;background-color:transparent}.form-control:focus{border-color:#555}.form-group.form-textarea label:after{position:absolute;content:'';width:2px;background-color:#fff;right:-2px;top:0;bottom:0}textarea.form-control{height:auto;resize:none;padding:1rem 0;border-bottom:2px solid #ccc;border-left:2px solid #ccc;padding:.5rem}select.form-control{border-radius:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}.help-block{color:#999;margin-top:.5rem}.form-actions{margin-bottom:1.75rem}.btn{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;outline:none;padding:.65rem 2rem;font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;z-index:1}.btn:active{box-shadow:inset 0 1px 3px rgba(0,0,0,.12)}.btn.btn-ghost{border-color:#757575;color:#757575;background-color:transparent}.btn.btn-ghost:focus,.btn.btn-ghost:hover{border-color:#424242;color:#424242;z-index:2}.btn.btn-ghost:hover{background-color:transparent}.btn-block{width:100%;display:-ms-flexbox;display:flex}.btn-default{color:#fff;background-color:#e0e0e0;border:1px solid #e0e0e0;color:#333}.btn-default:focus:not(.btn-ghost),.btn-default:hover{background-color:#dcdcdc;border-color:#dcdcdc}.btn-success{color:#fff;background-color:#4caf50;border:1px solid #4caf50}.btn-success:focus:not(.btn-ghost),.btn-success:hover{background-color:#43a047;border-color:#43a047}.btn-success.btn-ghost{border-color:#4caf50;color:#4caf50}.btn-success.btn-ghost:focus,.btn-success.btn-ghost:hover{border-color:#388e3c;color:#388e3c;z-index:2}.btn-error{color:#fff;background-color:#f44336;border:1px solid #f44336}.btn-error:focus:not(.btn-ghost),.btn-error:hover{background-color:#e53935;border-color:#e53935}.btn-error.btn-ghost{border-color:#f44336;color:#f44336}.btn-error.btn-ghost:focus,.btn-error.btn-ghost:hover{border-color:#d32f2f;color:#d32f2f;z-index:2}.btn-warning{color:#fff;background-color:#ff9800;border:1px solid #ff9800}.btn-warning:focus:not(.btn-ghost),.btn-warning:hover{background-color:#fb8c00;border-color:#fb8c00}.btn-warning.btn-ghost{border-color:#ff9800;color:#ff9800}.btn-warning.btn-ghost:focus,.btn-warning.btn-ghost:hover{border-color:#f57c00;color:#f57c00;z-index:2}.btn-info{color:#fff;background-color:#00bcd4;border:1px solid #00bcd4}.btn-info:focus:not(.btn-ghost),.btn-info:hover{background-color:#00acc1;border-color:#00acc1}.btn-info.btn-ghost{border-color:#00bcd4;color:#00bcd4}.btn-info.btn-ghost:focus,.btn-info.btn-ghost:hover{border-color:#0097a7;color:#0097a7;z-index:2}.btn-primary{color:#fff;background-color:#2196f3;border:1px solid #2196f3}.btn-primary:focus:not(.btn-ghost),.btn-primary:hover{background-color:#1e88e5;border-color:#1e88e5}.btn-primary.btn-ghost{border-color:#2196f3;color:#2196f3}.btn-primary.btn-ghost:focus,.btn-primary.btn-ghost:hover{border-color:#1976d2;color:#1976d2;z-index:2}.btn-group{overflow:auto}.btn-group .btn{float:left}.btn-group .btn-ghost:not(:first-child){margin-left:-1px}.card{border:1px solid #ccc}.card .card-header{color:#333;text-align:center;background-color:#ddd;padding:.5rem 0}.alert{color:#ccc;padding:1rem;border:1px solid #ccc;margin-bottom:1.75rem}.alert-success{color:#4caf50;border-color:#4caf50}.alert-error{color:#f44336;border-color:#f44336}.alert-info{color:#00bcd4;border-color:#00bcd4}.alert-warning{color:#ff9800;border-color:#ff9800}.media:not(:last-child){margin-bottom:1.25rem}.media-left{padding-right:1rem}.media-left,.media-right{display:table-cell;vertical-align:top}.media-right{padding-left:1rem}.media-body{display:table-cell;vertical-align:top}.media-heading{font-size:1.16667rem;font-weight:700}.media-content{margin-top:.3rem}.avatarholder,.placeholder{background-color:#f0f0f0;text-align:center;color:#b9b9b9;font-size:1rem;border:1px solid #f0f0f0}.avatarholder{width:48px;height:48px;line-height:46px;font-size:2rem;background-size:cover;background-position:50%;background-repeat:no-repeat}.avatarholder.rounded{border-radius:33px}.loading{height:20px;width:20px;animation:a .6s infinite linear;border:2px solid #e91e63;border-right-color:transparent;border-radius:50%}.btn .loading{display:inline-block;float:left;margin-right:.5rem;width:14px;height:14px}@keyframes a{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.menu{width:100%}.menu .menu-item{display:block;color:#616161;border-color:#616161}.menu .menu-item.active,.menu .menu-item:hover{color:#000;border-color:#000;background-color:transparent}@media screen and (max-width:768px){.form-group label{display:block;border-bottom:none;width:100%}.form-group.form-textarea label:after{display:none}.form-control{width:100%}textarea.form-control{border-left:none;padding:.5rem 0}pre::-webkit-scrollbar{height:3px}}@media screen and (max-width:480px){.form{width:100%}}
.dark{color:#ccc}.dark,.dark pre{background-color:#000}.dark pre{padding:0;border:none}.dark pre code{color:#00bcd4}.dark h1 a,.dark h2 a,.dark h3 a,.dark h4 a,.dark h5 a{color:#ccc}.dark code,.dark strong{color:#fff}.dark code{font-weight:100}.dark table{color:#ccc}.dark table td,.dark table th{border-color:#444}.dark table tbody td:first-child{color:#fff}.dark .form-group label{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-group.form-textarea label:after{background-color:#000}.dark .form-control{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-control:focus{border-color:#ccc;color:#ccc}.dark textarea.form-control{color:#ccc}.dark .card{border-color:rgba(95,95,95,.78)}.dark .card .card-header{background-color:transparent;color:#ccc;border-bottom:1px solid rgba(95,95,95,.78)}.dark .btn.btn-ghost.btn-default{border-color:#ababab;color:#ababab}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#9c9c9c;color:#9c9c9c;z-index:1}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#e0e0e0;color:#e0e0e0}.dark .btn.btn-ghost.btn-primary:focus,.dark .btn.btn-ghost.btn-primary:hover{border-color:#64b5f6;color:#64b5f6}.dark .btn.btn-ghost.btn-success:focus,.dark .btn.btn-ghost.btn-success:hover{border-color:#81c784;color:#81c784}.dark .btn.btn-ghost.btn-info:focus,.dark .btn.btn-ghost.btn-info:hover{border-color:#4dd0e1;color:#4dd0e1}.dark .btn.btn-ghost.btn-error:focus,.dark .btn.btn-ghost.btn-error:hover{border-color:#e57373;color:#e57373}.dark .btn.btn-ghost.btn-warning:focus,.dark .btn.btn-ghost.btn-warning:hover{border-color:#ffb74d;color:#ffb74d}.dark .avatarholder,.dark .placeholder{background-color:transparent;border-color:#333}.dark .menu .menu-item{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .menu .menu-item.active,.dark .menu .menu-item:hover{color:#fff;border-color:#ccc}

      @keyframes intro {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
.muted {
  color: rgba(255, 255, 255, 0.5);
}
main, footer {
  animation: intro 0.3s both;
  animation-delay: 0.15s;
}
:target {
  color: #fff;
}
/* hack.css overrides and enhancements */
.hack li ul {
  margin: 0;
}
.main {
  padding: 20px 10px;
}
nav a.active {
  background-color: #ff2e88;
  color: #fff;
}
a[itemprop="url"] {
  color: #ff9800;
}
a[itemprop="url"]:hover {
  color: #fff;
}
a[href*="//"]::after {
  /* data uri svg icon. thanks to @Fastidious for the idea */
  content: " " url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20class='i-external'%20viewBox='0%200%2032%2032'%20width='14'%20height='14'%20fill='none'%20stroke='%23ff9800'%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='9.38%'%3E%3Cpath%20d='M14%209%20L3%209%203%2029%2023%2029%2023%2018%20M18%204%20L28%204%2028%2014%20M28%204%20L14%2018'/%3E%3C/svg%3E");
}
html {
  font-size: 13px;
}
.hack pre {
  font-size: 17px;
}
article [itemprop="description"] {
  margin-bottom: 20px;
  margin-top: 20px;
}
@media screen and (min-width: 768px) {
  html {
    font-size: 1em;
  }
  .container {
    max-width: 50rem;
  }
}

      .highlight,pre.highlight{background:#282c34;color:#abb2bf}.highlight pre{background:#282c34}.highlight .ge{font-style:italic}.highlight .gs{font-weight:700}.highlight .ow{font-weight:700}.highlight .n,.highlight .nf,.highlight .nn,.highlight .o,.highlight .p{color:#abb2bf}.highlight .c,.highlight .c1,.highlight .cm,.highlight .cp,.highlight .cs{color:#5c6370;font-style:italic}.highlight .sr,.highlight .ss{color:#56b6c2}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kn,.highlight .kp,.highlight .kr,.highlight .kt{color:#c678dd}.highlight .l,.highlight .ld,.highlight .s,.highlight .s1,.highlight .s2,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .se,.highlight .sh,.highlight .si,.highlight .sx{color:#98c379}.highlight .nt,.highlight .nx,.highlight .vi{color:#e06c75}.highlight .il,.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .na{color:#d19a66}.highlight .bp,.highlight .nb,.highlight .nc,.highlight .nd,.highlight .ne,.highlight .ni,.highlight .nl,.highlight .no,.highlight .nv,.highlight .py,.highlight .vc,.highlight .vg{color:#e5c07b}.highlight .err{color:#fff;background-color:#e05252}.highlight .gd{color:#e05252}.highlight .gi{color:#43d08a}.highlight .w{color:#f8f8f2}.highlight .cpf{color:navy}.highlight .gu{color:#75715e}.highlight .lineno{color:#636d83;user-select:none}.highlight .hll{color:#abb2bf;background-color:#2c313a}.highlight .language-json .w+.s2{color:#e06c75}.highlight .language-json .kc{color:#56b6c2}

p img {
    width: 100%;
}

    </style>
    
    
  </head>
  
  <body class="hack dark main container">
    <header>
  
  <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
    
    
      <a itemprop="url" class="" href="/"><span itemprop="name">Home</span></a>
    
      <a itemprop="url" class="" href="/about-me/"><span itemprop="name">About</span></a>
    
      <a itemprop="url" class="active" href="/post/"><span itemprop="name">Posts</span></a>
    
      <a itemprop="url" class="" href="/roguelikes/"><span itemprop="name">Roguelike Development</span></a>
    
      <a itemprop="url" class="" href="http://source.jeremyceri.se"><span itemprop="name">Source</span></a>
    
  </nav>


</header>
    <main>
  <article itemscope itemtype="http://schema.org/BlogPosting">
    
<meta itemprop="name" content="RoguelikeDev Builds a Roguelike, Part 6">
<meta itemprop="description" content="Part 6: Preparing for Combat">


<meta itemprop="datePublished" content="2017-07-23T22:20:22-06:00" />
<meta itemprop="dateModified" content="2017-07-23T22:20:22-06:00" />
<meta itemprop="wordCount" content="2660">



<meta itemprop="keywords" content="RLDBAR,go,programming,roguelike,combat," />

    <header>
      <h1 itemprop="headline">RoguelikeDev Builds a Roguelike, Part 6</h1>
      <p class="muted">
        <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <circle cx="16" cy="16" r="14" />
  <path d="M16 8 L16 16 20 20" />
</svg>
<span>13 minute read</span>
<svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z" />
</svg>

  Published: <time datetime="2017-07-23T22:20:22-06:00">23 Jul, 2017</time>


      </p>
    </header>
    
      <blockquote itemprop="description">Part 6: Preparing for Combat</blockquote>
    
    

    <div itemprop="articleBody">
      <p>Welcome back to my series about building a Roguelike in Go (and following along with RoguelikeDev&rsquo;s dev-along)! Last time, we added a field of vision algorithm to our game, putting the player in the dark, except the immediate area surrounding them. In this installment, we&rsquo;re going to start adding the framework for monsters that inhabit the dark corners of the caverns. In particular, our goal will be to randomly place Game Entities, representing things such as Goblins, Troll, and Orcs, around our generated caverns, make sure they get to take actions, and allow the player to interact with them. We&rsquo;ll be adding proper combat in a later post, but for now, lets add some monsters!</p>

<!-- more -->

<p>A pertinent question that we should ask, before we dive in, is how are we going to represent the monsters that will inhabit the depths of our caverns? You may recall that we have a struct for just such a thing: GameEntity. Our GameEntity struct is exactly what we need to create monsters. GameEntity&rsquo;s sole purpose is to represent &lsquo;things&rsquo; in the game world, whether that be items, chests, NPCs, monsters, or the player. So far, we&rsquo;ve only used the GameEntity struct to represent our player (and a short lived NPC), but now we&rsquo;re going to start leveraging it much, much more.</p>

<p>We need to do some small additions to our GameEntity struct before we move forward. We&rsquo;re going to add a name property, as well as property that indicates whether this entity blocks movement (in the exact same way that a Tile does):</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">GameEntity</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">X</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">Layer</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">Char</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">Color</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">Blocks</span> <span style="color:#66d9ef">bool</span>
}</code></pre></div>

<p>Nothing fancy there, just a string and a bool.</p>

<p>Now that we have that additional data attached to our entities, lets put some thought into how we want to go about creating new monster entities, and adding them to our game world. The easiest approach to this, and the one we&rsquo;re going to stick with for the time being, is to just randomly place some created entities around the map. There are a few challenges with this approach however: 1) We don&rsquo;t want to place entities outside the bounds of where the player can go, and 2) we don&rsquo;t want to place entities on top of one another. Lets setup the solution for the second issue first.</p>

<p>What we need is a way to see if there is a blocking entity at a given location. The way this should work is that, whenever we go to place an entity on our map, we will feed the intended coordinates into a function that checks the location of every entity currently placed, and make sure that one of them is not present at the location we are trying to use. This should be pretty easy to do, as we are also going to be keeping a (more or less) global list of entities that are present on the map. A logical place for this code to live in our entity package. This new function doesn&rsquo;t need to be attached to the GameEntity struct, but from an organizational standpoint, it makes sense to put it in the same file:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">GetBlockingEntitiesAtLocation</span>(<span style="color:#a6e22e">entities</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">GameEntity</span>, <span style="color:#a6e22e">destinationX</span>, <span style="color:#a6e22e">destinationY</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">GameEntity</span> {
	<span style="color:#75715e">// Return any entities that are at the destination location which would block movement
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">entities</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Blocks</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">destinationX</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">destinationY</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}</code></pre></div>

<p>We pass in a slice containing every entity currently present on the map, and the intended (x, y) coordinates for our new entity. We then check to see if there is an entity present, and if it blocks. If it does, we simply return that entity, or nil if nothing is present at the desired location.</p>

<p>Alright, we&rsquo;ve now got a way to check valid entity locations, lets set about actually creating and placing a bunch of monster entities on our map!</p>

<p>At this point, I&rsquo;ve decided to refactor my previous code a bit. We&rsquo;re going to be dealing with map related functions (generating and placing monsters based on the type of map), so it makes sense that the monster generation and placement code lives in the gamemap package. Previously, I had one file, gamemap.go, which contained all the map logic. I decided, to keep things tidy, to break the gamemap.go file into three files: gamemap.go, which contains the core, common map logic; arena.go, which contains all code related to arena maps; and cavern.go, which contains all logic specific to caverns. You can look <a href="https://github.com/jcerise/roguelikedev-does-the-complete-roguelike-tutorial/tree/master/src/gamemap">here</a> to see the specifics of how this is now laid out. This is strictly an organizational change, so don&rsquo;t feel obligated to follow my lead, if you don&rsquo;t want to.</p>

<p>Anyways&hellip;</p>

<p>We&rsquo;re going to add a new function that will generate and place monsters in our cavern maps (I&rsquo;m ignoring arenas, since that&rsquo;s more for testing at the moment). Since we&rsquo;re dealing with cavern maps, I&rsquo;ve decided to call my function &lsquo;populateCavern&rsquo;. Lets look at the code, and I&rsquo;ll explain it afterwards:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">populateCavern</span>(<span style="color:#a6e22e">mainCave</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Tile</span>) []<span style="color:#f92672">*</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span> {
	<span style="color:#75715e">// Randomly sprinkle some Orcs, Trolls, and Goblins around the newly created cavern
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">entities</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">createdEntity</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
		<span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
		<span style="color:#a6e22e">locationFound</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">50</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#75715e">// Attempt to find a clear location to create a mob (entity for now)
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>() <span style="color:#f92672">%</span> len(<span style="color:#a6e22e">mainCave</span>)
			<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">mainCave</span>[<span style="color:#a6e22e">pos</span>].<span style="color:#a6e22e">X</span>
			<span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">mainCave</span>[<span style="color:#a6e22e">pos</span>].<span style="color:#a6e22e">Y</span>
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GetBlockingEntitiesAtLocation</span>(<span style="color:#a6e22e">entities</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">locationFound</span> = <span style="color:#66d9ef">true</span>
				<span style="color:#66d9ef">break</span>
			}
		}

		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">locationFound</span> {
			<span style="color:#a6e22e">chance</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Intn</span>(<span style="color:#ae81ff">100</span>)
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">chance</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">25</span> {
				<span style="color:#75715e">// Create a Troll
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">createdEntity</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>{<span style="color:#a6e22e">X</span>: <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">Y</span>: <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">Layer</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">Char</span>: <span style="color:#e6db74">&#34;T&#34;</span>, <span style="color:#a6e22e">Color</span>: <span style="color:#e6db74">&#34;dark green&#34;</span>, <span style="color:#a6e22e">Blocks</span>: <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;Troll&#34;</span>}
			} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">chance</span> &gt; <span style="color:#ae81ff">25</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">chance</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">50</span> {
				<span style="color:#75715e">// Create an Orc
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">createdEntity</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>{<span style="color:#a6e22e">X</span>: <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">Y</span>: <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">Layer</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">Char</span>: <span style="color:#e6db74">&#34;o&#34;</span>, <span style="color:#a6e22e">Color</span>: <span style="color:#e6db74">&#34;darker green&#34;</span>, <span style="color:#a6e22e">Blocks</span>: <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;Orc&#34;</span>}
			} <span style="color:#66d9ef">else</span> {
				<span style="color:#75715e">// Create a Goblin
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">createdEntity</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>{<span style="color:#a6e22e">X</span>: <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">Y</span>: <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">Layer</span>: <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">Char</span>: <span style="color:#e6db74">&#34;g&#34;</span>, <span style="color:#a6e22e">Color</span>: <span style="color:#e6db74">&#34;green&#34;</span>, <span style="color:#a6e22e">Blocks</span>: <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;Goblin&#34;</span>}
			}

			<span style="color:#a6e22e">entities</span> = append(<span style="color:#a6e22e">entities</span>, <span style="color:#a6e22e">createdEntity</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// No location was found after 50 tries, which means the map is quite full. Stop here and return.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">break</span>
		}
	}

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">entities</span>
}</code></pre></div>

<p>populateCavern() takes a list of Tiles called mainCave. You may remember from the post on map generation that our cavern generation algorithm keeps track of the main cave area used during the final steps of the process. We&rsquo;re going to pass that slice into our populateCavern() function, as it contains a list of all clear, non-wall Tiles in the playable area, which is exactly what we need.</p>

<p>We start off by creating a for loop. This outer loop will determine how many monsters we generate. I&rsquo;ve set mine to 2, but you can tweak that value to your liking. Next, we step into an inner loop, that runs no more than 50 times. This loop is going to attempt to find a valid, clear location for our new (yet to be created) monster. The reason for this loop is simple: we are going to randomly generate coordinates within our cavern, and then check if it is a clear (no blocking entity present) location. If it is not, we will iterate, and try again, with a new set of random coordinates. We will keep looping and looking until a valid location is found. If the loop runs for more than 50 iterations, its pretty safe to assume that there are no valid locations left, and the loop should break. This will prevent our game from endlessly looking for a valid location, when one may not even exist.</p>

<p>The location checker loop is pretty straight forward. We grab a random position within the mainCave, and get the (X, Y) values from the Tile at that location. We then use our new GetBlockingEntitiesAtLocation() function, passing in the randomly generated (x, y) coordinates. If that function returns nil, we have found a valid location, and we set the locationFound variable to true, and break out of the loop. If no valid location is found, we try again. If all 50 iterations are used up, the loop will end, with locationFound still having a value of false.</p>

<p>Next, if a location was in fact found, we generate a random number between 1 and 100. This will give us a 25% chance of creating a Troll, a 25% chance of creating an Orc, and a 50% chance of creating a Goblin. We then create the appropriate entity, using our new name and blocks properties.</p>

<p>Finally, we append the newly created entity onto the local entities slice, which will be returned.</p>

<p>We&rsquo;ve now got some entities, in valid locations, for our map. Lets quickly look at the code in GenerateCavern() that calls this new function:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">GenerateCavern</span>() (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, []<span style="color:#f92672">*</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>) {
    <span style="color:#f92672">...</span>

  <span style="color:#75715e">// Populate the cavern with some nasty critters
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">entities</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">populateCavern</span>(<span style="color:#a6e22e">mainCave</span>)

	<span style="color:#75715e">// Finally, choose a starting position for the player within the newly created cave
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pos</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>() <span style="color:#f92672">%</span> len(<span style="color:#a6e22e">mainCave</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mainCave</span>[<span style="color:#a6e22e">pos</span>].<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">mainCave</span>[<span style="color:#a6e22e">pos</span>].<span style="color:#a6e22e">Y</span>, <span style="color:#a6e22e">entities</span>
}</code></pre></div>

<p>You can see I&rsquo;ve changed the signature a bit, as GenerateCavern() now returns a slice of GameEntity, alongside the valid coordinates for the player. Beyond that, we simply call the populateCavern() function, and assign the slice of returned entities to the &lsquo;entities&rsquo; variable, and then return that alongside the players (x, y) position.</p>

<p>Finally, lets get those entities drawn to the screen! Back in our main file, in our init() function, we&rsquo;re going to add a small update:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {
  <span style="color:#f92672">...</span>

  <span style="color:#a6e22e">playerX</span>, <span style="color:#a6e22e">playerY</span>, <span style="color:#a6e22e">mapEntities</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gameMap</span>.<span style="color:#a6e22e">GenerateCavern</span>()
	<span style="color:#a6e22e">player</span>.<span style="color:#a6e22e">X</span> = <span style="color:#a6e22e">playerX</span>
	<span style="color:#a6e22e">player</span>.<span style="color:#a6e22e">Y</span> = <span style="color:#a6e22e">playerY</span>

	<span style="color:#a6e22e">entities</span> = append(<span style="color:#a6e22e">entities</span>, <span style="color:#a6e22e">mapEntities</span><span style="color:#f92672">...</span>)

  <span style="color:#f92672">...</span>
}</code></pre></div>

<p>We&rsquo;re now grabbing the returned GameEntity slice from our GenerateCavern() function. Earlier, we created a slice called entities (of which our player is a part) that was intended to contain every entity currently on the map. Here, we are simply appending the mapEntities slice to the (sort of) global entities slice. This will ensure that our entities from our map generation get drawn correctly, along side our player, each turn!</p>

<p><img src="/static/week-3-part-2-monsters-dumb.png" alt="Monsters on the map" /></p>

<p>(You may notice that there is console output on my game. This is the topic of an upcoming SideNote, so stay tuned if that interests you.)</p>

<p>We&rsquo;ve successfully generated, placed, and drawn several (not yet) threatening monsters onto our game map. But&hellip;they don&rsquo;t really do much, and if the player attempts to interact with them, you&rsquo;ll find you can walk right through them as if they&rsquo;re not even there. These are some cut-rate monsters&hellip; Lets fix that!</p>

<p>As it stands right now, the player takes an action (currently only moving is implemented), and then is allowed to take another action, and another, and another, ad nauseum. We need a way to let the monsters take a turn, after the player has done something. Essentially, we are going to consider one action by the player to be his turn. So, the player moving north one Tile, or the player drinking a potion, or resting, these are all actions that would end the players turn. Once the player has acted, we want to let the monsters on the map do something as well. We&rsquo;re going to need some way of keeping track of the current turn, or game state.</p>

<p>Lets do that first. We&rsquo;ll create a couple of new constants, one called PlayerTurn, and one called MobTurn. What we&rsquo;re aiming for is basically an enum that we can reference to check or set the current state of the game, the players turn, or the monsters turn. Since Go doesn&rsquo;t have direct support for an enum type, I&rsquo;m going to use a language feature called &lsquo;iota&rsquo;. The iota keyword will auto-increment its value each time we call it, meaning that if we call it three times in sequence, each call will have a value of (1 + last_iota_value). This is super handy for creating enum like variable sets:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> (
	<span style="color:#a6e22e">WindowSizeX</span> = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">WindowSizeY</span> = <span style="color:#ae81ff">35</span>
	<span style="color:#a6e22e">MapWidth</span> = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">MapHeight</span> = <span style="color:#ae81ff">35</span>
	<span style="color:#a6e22e">Title</span> = <span style="color:#e6db74">&#34;BearRogue&#34;</span>
	<span style="color:#a6e22e">Font</span> = <span style="color:#e6db74">&#34;fonts/UbuntuMono.ttf&#34;</span>
	<span style="color:#a6e22e">FontSize</span> = <span style="color:#ae81ff">24</span>
	<span style="color:#a6e22e">PlayerTurn</span> = <span style="color:#66d9ef">iota</span>
	<span style="color:#a6e22e">MobTurn</span> = <span style="color:#66d9ef">iota</span>
)</code></pre></div>

<p>Now, I&rsquo;m going to set a new variable called gameTurn:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> (
	<span style="color:#a6e22e">player</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>
	<span style="color:#a6e22e">entities</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>
	<span style="color:#a6e22e">gameMap</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gamemap</span>.<span style="color:#a6e22e">Map</span>
	<span style="color:#a6e22e">gameCamera</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">camera</span>.<span style="color:#a6e22e">GameCamera</span>
	<span style="color:#a6e22e">fieldOfView</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">fov</span>.<span style="color:#a6e22e">FieldOfVision</span>
	<span style="color:#a6e22e">gameTurn</span> <span style="color:#66d9ef">int</span>
)</code></pre></div>

<p>Finally, in our init() function, we&rsquo;re going to set the gameTurn to the player:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {

    <span style="color:#f92672">...</span>

    <span style="color:#75715e">// Set the current turn to the player, so they may act first
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gameTurn</span> = <span style="color:#a6e22e">PlayerTurn</span>

    <span style="color:#f92672">...</span>
}</code></pre></div>

<p>The gameTurn variable will regularly get flipped from state to state. Once the player takes an action, it flips to MobTurn, and the monsters all get to take one action. Once they are done, it will flip back to PlayerTurn, etc. This sets up a nice turn by turn flow for the game, with every entity getting one action per turn.</p>

<p>Now, in our main game loop, we need to implement that logic. Turns out, its pretty simple:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#f92672">...</span>

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">blt</span>.<span style="color:#a6e22e">TK_CLOSE</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gameTurn</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">PlayerTurn</span> {
				<span style="color:#a6e22e">handleInput</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">player</span>)
			}
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">break</span>
		}

		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gameTurn</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">MobTurn</span> {
			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">entities</span> {
				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">player</span> {
					<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gameMap</span>.<span style="color:#a6e22e">Tiles</span>[<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">X</span>][<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Y</span>].<span style="color:#a6e22e">Visible</span> {
						<span style="color:#75715e">// Check to ensure that the entity is visible before allowing it to message the player
</span><span style="color:#75715e"></span>						<span style="color:#75715e">// This will change soon, as entities will act whether the player can see them or not.
</span><span style="color:#75715e"></span>						<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;The %s waits patiently...&#34;</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">Name</span>)
					}
				}
			}
			<span style="color:#a6e22e">gameTurn</span> = <span style="color:#a6e22e">PlayerTurn</span>
		}
    <span style="color:#f92672">...</span>
}</code></pre></div>

<p>When we check for player input, we also check to see if it is in fact the players turn. If it is, we allow the input to be processed. If not, we skip over the action and continue. If it is the players turn, we call handleInput as normal, but there&rsquo;s one small change in there:</p>

<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handleInput</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">player</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GameEntity</span>) {
    <span style="color:#f92672">...</span>

    <span style="color:#75715e">// Check to ensure that the tile the player is trying to move in to is a valid move (not blocked)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">gameMap</span>.<span style="color:#a6e22e">IsBlocked</span>(<span style="color:#a6e22e">player</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">dx</span>, <span style="color:#a6e22e">player</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">dy</span>) {
		<span style="color:#a6e22e">target</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">entity</span>.<span style="color:#a6e22e">GetBlockingEntitiesAtLocation</span>(<span style="color:#a6e22e">entities</span>, <span style="color:#a6e22e">player</span>.<span style="color:#a6e22e">X</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">dx</span>, <span style="color:#a6e22e">player</span>.<span style="color:#a6e22e">Y</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">dy</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;You harmlessly bump into the %s&#34;</span>, <span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">Name</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">player</span>.<span style="color:#a6e22e">Move</span>(<span style="color:#a6e22e">dx</span>, <span style="color:#a6e22e">dy</span>)
		}
	}

	<span style="color:#75715e">// Switch the game turn to the Mobs turn
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gameTurn</span> = <span style="color:#a6e22e">MobTurn</span>
}</code></pre></div>

<p>After we check if the desired location is blocked, we also check to see if there is a blocking entity present. If there is, we stop the movement, similar to how we stop movement into a wall, and print a message letting the player know that they have bumped into something nasty. Finally, we switch the game turn to the monsters.</p>

<p>Back in the main game loop, we check if its the monsters turn. If it is, we loop (naively right now, we&rsquo;ll make this better later) through every entity on the map, being sure to skip the player, and let them take an action. Right now that action consists of printing out that its waiting patiently, but later this will be things like moving, attacking, etc.</p>

<p>And that&rsquo;s it! If you fire up the game now, you should be able to find some monsters, which should act in reaction to your movement, and allow you to harmlessly bump into them.</p>

<p>This has laid the groundwork for our upcoming combat system. We&rsquo;ve allowed the player to interact with other entities, a theme we&rsquo;re going to continue to develop, as its one of the core mechanics of the game. We also set up a system to randomly fill our caves and dungeons with all sorts of nasty creatures, just waiting to hassle the player.</p>

<p>As usual, if you want to see the code for this post, you can find it <a href="https://github.com/jcerise/roguelikedev-does-the-complete-roguelike-tutorial/releases/tag/v0.0.7">here</a>. Next time, we&rsquo;ll be fleshing out the combat system, and adding some nice GUI components. Until then, happy developing!</p>

<p><a href="/post/roguelike-dev-part-7/">This way to Part 7: ECS Refactor</a></p>

    </div>
    
    <footer>
      <hr>
      <p>
  Published
  
    
      by <span itemprop="author">Jeremy Cerise</span>
    
  
  <time datetime="2017-07-23T22:20:22-06:00">
    23 Jul, 2017
  </time>
  
    in <span itemprop="articleSection"><a href="/categories/technology/">technology</a></span>
  
  
    and tagged <a href="/tags/rldbar/">RLDBAR</a>, <a href="/tags/combat/">combat</a>, <a href="/tags/go/">go</a>, <a href="/tags/programming/">programming</a> and <a href="/tags/roguelike/">roguelike</a>
  
  using <span itemprop="wordCount">2660</span> words.
</p>

      
  



  <aside>
    <header>Related Content</header>
    <ul>
      
      
        <li><a href="/post/roguelike-dev-part-7/">RoguelikeDev Builds a Roguelike, Part 7</a> &ndash; 17 minutes
      
        <li><a href="/post/sidenote-2-vim-keys/">RLDBAR Sidenote #2: Vim Keys and Diagonal Movement</a> &ndash; 2 minutes
      
        <li><a href="/post/roguelike-dev-week-3-part-1/">RoguelikeDev Builds a Roguelike, Part 5</a> &ndash; 12 minutes
      
        <li><a href="/post/roguelike-dev-week-2/">RoguelikeDev Builds a Roguelike, Part 4</a> &ndash; 18 minutes
      
        <li><a href="/post/sidenote-1-cameras/">RLDBAR Sidenote #1: Cameras</a> &ndash; 9 minutes
      
        <li><a href="/post/roguelike-dev-week-1-part-2/">RoguelikeDev Builds A Roguelike, Part 3</a> &ndash; 18 minutes
      
        <li><a href="/post/roguelike-dev-week-1-part-1/">RoguelikeDev Builds a Roguelike, Part 2</a> &ndash; 8 minutes
      
    </ul>
  </aside>


    </footer>
  </article>
</main>
    <footer>
  
  <p class="muted">
    This page was generated using
    <a target="_blank" rel="noopener" href="https://comfusion.github.io/after-dark/">After Dark</a>
    for
    <a target="_blank" rel="noopener" href="https://gohugo.io/">Hugo</a>.
  </p>


</footer>
  </body>
</html>
