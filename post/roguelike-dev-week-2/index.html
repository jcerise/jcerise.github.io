<!doctype html>
<html lang="en-US">
  <head>
    


  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:; connect-src 'self' wss: data:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'">


    <meta name="generator" content="After Dark Hugo">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoguelikeDev Builds a Roguelike, Part 4 | Jeremy&#39;s Ramblings</title>
    <meta name="description" content="Part 4: A more interesting map">
    <meta name="keywords" content="RLDBAR, go, programming, roguelike, cellular automata">
    
    
    
    
    <meta property="og:title" content="RoguelikeDev Builds a Roguelike, Part 4" />
<meta property="og:description" content="Part 4: A more interesting map" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeremyceri.se/post/roguelike-dev-week-2/" />
<meta property="og:image" content="https://source.unsplash.com/collection/983219/2000x1322"/>
<meta property="article:published_time" content="2017-07-11T13:41:06-06:00" />
<meta property="article:modified_time" content="2017-07-11T13:41:06-06:00" />

    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://source.unsplash.com/collection/983219/2000x1322"/>

<meta name="twitter:title" content="RoguelikeDev Builds a Roguelike, Part 4"/>
<meta name="twitter:description" content="Part 4: A more interesting map"/>

    



  <meta property="og:image" content="https://source.unsplash.com/collection/983219/2000x1322">


    

    
    
  <meta name="referrer" content="same-origin">


    
    
    <script integrity="sha512-2t0yyNrUdtn9WGIoBVxq5vtoJQYfoDQDbqRPpOb75f1hiL39DGLdJKDrGP60fBhXfrFeKyVhzWJvHvLgln/ElA==">/*! Fetch Inject v2.0.4 | Copyright (C) Josh Habdas <jhabdas@protonmail.com> (https://habd.as) | @license Zlib */
var fetchInject=function(){"use strict";const e=function(e,t,r,n,o,c,i){c=t.createElement(r),i=t.getElementsByTagName(r)[0],c.appendChild(t.createTextNode(n.text)),c.onload=o(n),i?i.parentNode.insertBefore(c,i):t.head.appendChild(c)};return function(t,r){if(!arguments.length)return Promise.reject(new ReferenceError("Failed to execute 'fetchInject': 1 argument required but only 0 present."));if(arguments[0]&&arguments[0].constructor!==Array)return Promise.reject(new TypeError("Failed to execute 'fetchInject': argument 1 must be of type 'Array'."));if(arguments[1]&&arguments[1].constructor!==Promise)return Promise.reject(new TypeError("Failed to execute 'fetchInject': argument 2 must be of type 'Promise'."));const n=[],o=r?[].concat(r):[],c=[];return t.forEach(e=>o.push(window.fetch(e).then(e=>[e.clone().text(),e.blob()]).then(e=>Promise.all(e).then(e=>{n.push({text:e[0],blob:e[1]})})))),Promise.all(o).then(()=>(n.forEach(t=>{c.push({then:r=>{t.blob.type.includes("text/css")?e(window,document,"style",t,r):e(window,document,"script",t,r)}})}),Promise.all(c)))}}();
</script>
    <script integrity="sha512-2XlvnxweZhaHgBdCoOK0PoCUWiSfKibb&#43;RCRZNgqLdvbnx0ZH67FDGKQqmpqCerjMJbZFv6fsXgbmJOOA9K&#43;qA==">/*!
 * Copyright (C) 2019  Josh Habdas <jhabdas@protonmail.com>
 *
 * This file is part of After Dark.
 *
 * After Dark is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * After Dark is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

fetchInject(["/js/lazysizes.min.js"]);
</script>
    


  
    

  <meta title="mod:fractal-forest" content="status:enabled">
  
    <script async src=/js/bpgdec8a.js integrity=sha384-8PG0go3BW8hLm63KbTxk/hNcehaoSbrAhKzsmy2Jhs/KY8QdiKKkjhdeyHY/Q/0I&#10;></script>
  


  
  
  
  


    
    <link rel="canonical" href="https://jeremyceri.se/post/roguelike-dev-week-2/">
    
    
    <link rel="icon" sizes="any" href="data:image/svg+xml,%3Csvg%20viewBox='0%200%2046%2045'%20xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EAfter%20Dark%3C/title%3E%3Cpath%20d='M.708%2045L23%20.416%2045.292%2045H.708zM35%2038L23%2019%2011%2038h24z'%20fill='%23000'/%3E%3C/svg%3E">

    

  
  
  
  
  
  
  
    
      
        <style>html{font-size:12px}*{box-sizing:border-box;text-rendering:geometricPrecision}body{font-size:1rem;line-height:1.5rem;margin:0;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.3em}fieldset{border:none;padding:0;margin:0}pre{padding:2rem;margin:1.75rem 0;background-color:#fff;border:1px solid #ccc;overflow:auto}code[class*=language-],pre[class*=language-],pre code{font-weight:100;text-shadow:none;margin:1.75rem 0}a{cursor:pointer;color:#ff2e88;text-decoration:none;border-bottom:1px solid #ff2e88}a:hover{background-color:#ff2e88;color:#fff}.grid{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.grid.\-top{-ms-flex-align:start;align-items:flex-start}.grid.\-middle{-ms-flex-align:center;align-items:center}.grid.\-bottom{-ms-flex-align:end;align-items:flex-end}.grid.\-stretch{-ms-flex-align:stretch;align-items:stretch}.grid.\-baseline{-ms-flex-align:baseline;align-items:baseline}.grid.\-left{-ms-flex-pack:start;justify-content:flex-start}.grid.\-center{-ms-flex-pack:center;justify-content:center}.grid.\-right{-ms-flex-pack:end;justify-content:flex-end}.grid.\-between{-ms-flex-pack:justify;justify-content:space-between}.grid.\-around{-ms-flex-pack:distribute;justify-content:space-around}.cell{-ms-flex:1;flex:1;box-sizing:border-box}@media screen and (min-width:768px){.cell.\-1of12{-ms-flex:0 0 8.33333%;flex:0 0 8.33333%}.cell.\-2of12{-ms-flex:0 0 16.66667%;flex:0 0 16.66667%}.cell.\-3of12{-ms-flex:0 0 25%;flex:0 0 25%}.cell.\-4of12{-ms-flex:0 0 33.33333%;flex:0 0 33.33333%}.cell.\-5of12{-ms-flex:0 0 41.66667%;flex:0 0 41.66667%}.cell.\-6of12{-ms-flex:0 0 50%;flex:0 0 50%}.cell.\-7of12{-ms-flex:0 0 58.33333%;flex:0 0 58.33333%}.cell.\-8of12{-ms-flex:0 0 66.66667%;flex:0 0 66.66667%}.cell.\-9of12{-ms-flex:0 0 75%;flex:0 0 75%}.cell.\-10of12{-ms-flex:0 0 83.33333%;flex:0 0 83.33333%}.cell.\-11of12{-ms-flex:0 0 91.66667%;flex:0 0 91.66667%}}@media screen and (max-width:768px){.grid{-ms-flex-direction:column;flex-direction:column}.cell{-ms-flex:0 0 auto;flex:0 0 auto}}.hack,.hack blockquote,.hack code,.hack em,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack strong{font-size:1rem;font-style:normal;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif}.hack blockquote,.hack code,.hack em,.hack strong{line-height:20px}.hack blockquote,.hack code,.hack footer,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack header,.hack li,.hack ol,.hack p,.hack section,.hack ul{float:none;margin:0;padding:0}.hack blockquote,.hack h1,.hack ol,.hack p,.hack ul{margin-top:20px;margin-bottom:20px}.hack h1{position:relative;display:inline-block;display:table-cell;padding:20px 0 30px;margin:0;overflow:hidden}.hack h1:after{content:"====================================================================================================";position:absolute;bottom:10px;left:0}.hack h1+*{margin-top:0}.hack h2,.hack h3,.hack h4,.hack h5,.hack h6{position:relative;margin-bottom:1.75rem}.hack h2:before,.hack h3:before,.hack h4:before,.hack h5:before,.hack h6:before{display:inline}.hack h2:before{content:"## "}.hack h3:before{content:"### "}.hack h4:before{content:"#### "}.hack h5:before{content:"##### "}.hack h6:before{content:"###### "}.hack li{position:relative;display:block;padding-left:20px}.hack li:after{position:absolute;top:0;left:0}.hack ul>li:after{content:"-"}.hack ol{counter-reset:a}.hack ol>li:after{content:counter(a) ".";counter-increment:a}.hack ol li:nth-child(n+10):after{left:-7px}.hack blockquote{position:relative;padding-left:17px;padding-left:2ch;overflow:hidden}.hack blockquote:after{content:">\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>";white-space:pre;position:absolute;top:0;left:0;line-height:20px}.hack em:after,.hack em:before{content:"*";display:inline}.hack pre code:after,.hack pre code:before{content:""}.hack code{font-weight:700}.hack code:after,.hack code:before{content:"`";display:inline}.hack hr{position:relative;height:20px;overflow:hidden;border:0;margin:20px 0}.hack hr:after{content:"----------------------------------------------------------------------------------------------------";position:absolute;top:0;left:0;line-height:20px;width:100%;word-wrap:break-word}@-moz-document url-prefix(){.hack h1{display:block}}.hack-ones ol>li:after{content:"1."}p{margin:0 0 1.75rem}.container{max-width:70rem}.container,.container-fluid{margin:0 auto;padding:0 1rem}.inner{padding:1rem}.inner2x{padding:2rem}.pull-left{float:left}.pull-right{float:right}.progress-bar{height:8px;opacity:.8;background-color:#ccc;margin-top:12px}.progress-bar.progress-bar-show-percent{margin-top:38px}.progress-bar-filled{background-color:gray;height:100%;transition:width .3s ease;position:relative;width:0}.progress-bar-filled:before{content:"";border:6px solid transparent;border-top-color:gray;position:absolute;top:-12px;right:-6px}.progress-bar-filled:after{color:gray;content:attr(data-filled);display:block;font-size:12px;white-space:nowrap;position:absolute;border:6px solid transparent;top:-38px;right:0;-ms-transform:translateX(50%);transform:translateX(50%)}table{width:100%;border-collapse:collapse;margin:1.75rem 0;color:#778087}table td,table th{vertical-align:top;border:1px solid #ccc;line-height:15px;padding:10px}table thead th{font-size:10px}table tbody td:first-child{font-weight:700;color:#333}.form{width:30rem}.form-group{margin-bottom:1.75rem;overflow:auto}.form-group label{border-bottom:2px solid #ccc;color:#333;width:10rem;display:inline-block;height:38px;line-height:38px;padding:0;float:left;position:relative}.form-group.form-success label{color:#4caf50!important;border-color:#4caf50!important}.form-group.form-warning label{color:#ff9800!important;border-color:#ff9800!important}.form-group.form-error label{color:#f44336!important;border-color:#f44336!important}.form-control{outline:none;border:none;border-bottom:2px solid #ccc;padding:.5rem 0;width:20rem;height:38px;background-color:transparent}.form-control:focus{border-color:#555}.form-group.form-textarea label:after{position:absolute;content:"";width:2px;background-color:#fff;right:-2px;top:0;bottom:0}textarea.form-control{height:auto;resize:none;padding:1rem 0;border-bottom:2px solid #ccc;border-left:2px solid #ccc;padding:.5rem}select.form-control{border-radius:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}.help-block{color:#999;margin-top:.5rem}.form-actions{margin-bottom:1.75rem}.btn{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;outline:none;padding:.65rem 2rem;font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;z-index:1}.btn:active{box-shadow:inset 0 1px 3px rgba(0,0,0,.12)}.btn.btn-ghost{border-color:#757575;color:#757575;background-color:transparent}.btn.btn-ghost:focus,.btn.btn-ghost:hover{border-color:#424242;color:#424242;z-index:2}.btn.btn-ghost:hover{background-color:transparent}.btn-block{width:100%;display:-ms-flexbox;display:flex}.btn-default{color:#fff;background-color:#e0e0e0;border:1px solid #e0e0e0;color:#333}.btn-default:focus:not(.btn-ghost),.btn-default:hover{background-color:#dcdcdc;border-color:#dcdcdc}.btn-success{color:#fff;background-color:#4caf50;border:1px solid #4caf50}.btn-success:focus:not(.btn-ghost),.btn-success:hover{background-color:#43a047;border-color:#43a047}.btn-success.btn-ghost{border-color:#4caf50;color:#4caf50}.btn-success.btn-ghost:focus,.btn-success.btn-ghost:hover{border-color:#388e3c;color:#388e3c;z-index:2}.btn-error{color:#fff;background-color:#f44336;border:1px solid #f44336}.btn-error:focus:not(.btn-ghost),.btn-error:hover{background-color:#e53935;border-color:#e53935}.btn-error.btn-ghost{border-color:#f44336;color:#f44336}.btn-error.btn-ghost:focus,.btn-error.btn-ghost:hover{border-color:#d32f2f;color:#d32f2f;z-index:2}.btn-warning{color:#fff;background-color:#ff9800;border:1px solid #ff9800}.btn-warning:focus:not(.btn-ghost),.btn-warning:hover{background-color:#fb8c00;border-color:#fb8c00}.btn-warning.btn-ghost{border-color:#ff9800;color:#ff9800}.btn-warning.btn-ghost:focus,.btn-warning.btn-ghost:hover{border-color:#f57c00;color:#f57c00;z-index:2}.btn-info{color:#fff;background-color:#00bcd4;border:1px solid #00bcd4}.btn-info:focus:not(.btn-ghost),.btn-info:hover{background-color:#00acc1;border-color:#00acc1}.btn-info.btn-ghost{border-color:#00bcd4;color:#00bcd4}.btn-info.btn-ghost:focus,.btn-info.btn-ghost:hover{border-color:#0097a7;color:#0097a7;z-index:2}.btn-primary{color:#fff;background-color:#2196f3;border:1px solid #2196f3}.btn-primary:focus:not(.btn-ghost),.btn-primary:hover{background-color:#1e88e5;border-color:#1e88e5}.btn-primary.btn-ghost{border-color:#2196f3;color:#2196f3}.btn-primary.btn-ghost:focus,.btn-primary.btn-ghost:hover{border-color:#1976d2;color:#1976d2;z-index:2}.btn-group{overflow:auto}.btn-group .btn{float:left}.btn-group .btn-ghost:not(:first-child){margin-left:-1px}.card{border:1px solid #ccc}.card .card-header{color:#333;text-align:center;background-color:#ddd;padding:.5rem 0}.alert{color:#ccc;padding:1rem;border:1px solid #ccc;margin-bottom:1.75rem}.alert-success{color:#4caf50;border-color:#4caf50}.alert-error{color:#f44336;border-color:#f44336}.alert-info{color:#00bcd4;border-color:#00bcd4}.alert-warning{color:#ff9800;border-color:#ff9800}.media:not(:last-child){margin-bottom:1.25rem}.media-left{padding-right:1rem}.media-left,.media-right{display:table-cell;vertical-align:top}.media-right{padding-left:1rem}.media-body{display:table-cell;vertical-align:top}.media-heading{font-size:1.16667rem;font-weight:700}.media-content{margin-top:.3rem}.avatarholder,.placeholder{background-color:#f0f0f0;text-align:center;color:#b9b9b9;font-size:1rem;border:1px solid #f0f0f0}.avatarholder{width:48px;height:48px;line-height:46px;font-size:2rem;background-size:cover;background-position:50%;background-repeat:no-repeat}.avatarholder.rounded{border-radius:33px}.loading{display:inline-block;content:"&nbsp;";height:20px;width:20px;margin:0 .5rem;animation:a .6s infinite linear;border:2px solid #e91e63;border-right-color:transparent;border-radius:50%}.btn .loading{margin-bottom:0;width:14px;height:14px}.btn div.loading{float:left}.alert .loading{margin-bottom:-5px}@keyframes a{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.menu{width:100%}.menu .menu-item{display:block;color:#616161;border-color:#616161}.menu .menu-item.active,.menu .menu-item:hover{color:#000;border-color:#000;background-color:transparent}@media screen and (max-width:768px){.form-group label{display:block;border-bottom:none;width:100%}.form-group.form-textarea label:after{display:none}.form-control{width:100%}textarea.form-control{border-left:none;padding:.5rem 0}pre::-webkit-scrollbar{height:3px}}@media screen and (max-width:480px){.form{width:100%}}.dark{color:#ccc}.dark,.dark pre{background-color:#000}.dark pre{padding:0;border:none}.dark pre code{color:#00bcd4}.dark h1 a,.dark h2 a,.dark h3 a,.dark h4 a,.dark h5 a{color:#ccc}.dark code,.dark strong{color:#fff}.dark code{font-weight:100}.dark table{color:#ccc}.dark table td,.dark table th{border-color:#444}.dark table tbody td:first-child{color:#fff}.dark .form-group label{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-group.form-textarea label:after{background-color:#000}.dark .form-control{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-control:focus{border-color:#ccc;color:#ccc}.dark textarea.form-control{color:#ccc}.dark .card{border-color:rgba(95,95,95,.78)}.dark .card .card-header{background-color:transparent;color:#ccc;border-bottom:1px solid rgba(95,95,95,.78)}.dark .btn.btn-ghost.btn-default{border-color:#ababab;color:#ababab}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#9c9c9c;color:#9c9c9c;z-index:1}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#e0e0e0;color:#e0e0e0}.dark .btn.btn-ghost.btn-primary:focus,.dark .btn.btn-ghost.btn-primary:hover{border-color:#64b5f6;color:#64b5f6}.dark .btn.btn-ghost.btn-success:focus,.dark .btn.btn-ghost.btn-success:hover{border-color:#81c784;color:#81c784}.dark .btn.btn-ghost.btn-info:focus,.dark .btn.btn-ghost.btn-info:hover{border-color:#4dd0e1;color:#4dd0e1}.dark .btn.btn-ghost.btn-error:focus,.dark .btn.btn-ghost.btn-error:hover{border-color:#e57373;color:#e57373}.dark .btn.btn-ghost.btn-warning:focus,.dark .btn.btn-ghost.btn-warning:hover{border-color:#ffb74d;color:#ffb74d}.dark .avatarholder,.dark .placeholder{background-color:transparent;border-color:#333}.dark .menu .menu-item{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .menu .menu-item.active,.dark .menu .menu-item:hover{color:#fff;border-color:#ccc}/*!* Copyright (C) 2019 Josh Habdas <jhabdas@protonmail.com>
*
* This file is part of After Dark.
*
* After Dark is free software: you can redistribute it and/or modify
* it under the terms of the GNU Affero General Public License as published
* by the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* After Dark is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU Affero General Public License for more details.
*
* You should have received a copy of the GNU Affero General Public License
* along with this program. If not, see <https://www.gnu.org/licenses/>.*/:root{scroll-behavior:smooth;--screen-size-small: 30em}@keyframes intro{0%{opacity:0}100%{opacity:1}}.blur-up.lazyloading{filter:blur(5px);opacity:1;transition:opacity 1s,filter 1.5s}.blur-up.lazyload{opacity:0;filter:blur(10px)}.blur-up.lazyloaded{filter:blur(0);transition:filter 1s}.hack .readmore{margin-bottom:2.2em}.responsive-iframe,.ratio-container{position:relative;padding-bottom:56.25%;padding-top:25px;height:0}.responsive-iframe iframe,.ratio-container>*:not([itemprop=caption]){position:absolute;top:0;left:0;width:100%;height:100%}iframe{border:0}main,footer{animation:intro .3s both;animation-delay:.15s}header:first-of-type+details{margin:20px 0}footer time[datetime$=M]:before{content:"\2013\0020"}body>footer p.muted{margin-bottom:0}@media only screen and (max-width:768px){footer time[datetime$=M]{display:none}}blockquote cite{display:block}blockquote cite::before{content:"\2014\00A0"}:target{filter:brightness(1.2)}:disabled{cursor:not-allowed}.hack li ul{margin:0}.hack ol li{padding-left:27px}.main{padding:20px 10px}input.form-control{border-radius:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}input.form-control,textarea.form-control,select.form-control,.help-block{font-size:initial}@media only screen and (max-width:768px){.help-block{font-size:unset}}html{font-size:13px}.hack .form input,.hack .form textarea,.hack .form button,.hack .form label{font-size:1rem}.hack .alert .highlight:first-of-type .chroma,.hack .card .highlight:first-of-type .chroma,.hack .alert pre:first-of-type,.hack .alert p:first-of-type,.hack .card pre:first-of-type,.hack .card p:first-of-type{margin-top:unset}.hack .alert .highlight:last-of-type .chroma,.hack .card .highlight:last-of-type .chroma,.hack .alert pre:last-of-type,.hack .alert p:last-of-type,.hack .card pre:last-of-type,.hack .card p:last-of-type{margin-bottom:unset}.hack blockquote,.hack blockquote:after{line-height:1.5}.hack figure,.standard figure{margin:unset}.hack figure a{border-bottom:none}.hack figure a:hover{background-color:inherit}article header img{width:100%;border-radius:3px}table td,table th{line-height:inherit}table a{border-bottom:unset}img{max-width:100%}@media only screen and (min-width:768px){html{font-size:16px}.container{max-width:50rem}}@media only screen and (min-width:768px),(-ms-high-contrast:active),(-ms-high-contrast:none){html{margin-left:calc(100vw - 100%)}}/*!
 * Copyright (C) 2019  Josh Habdas <jhabdas@protonmail.com>
 *
 * This file is part of After Dark.
 *
 * After Dark is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * After Dark is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

a[rel*="external"]::after {
  content: " " url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20class='i-external'%20viewBox='0%200%2032%2032'%20width='14'%20height='14'%20fill='none'%20stroke='%23ff9800'%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='9.38%'%3E%3Cpath%20d='M14%209%20L3%209%203%2029%2023%2029%2023%2018%20M18%204%20L28%204%2028%2014%20M28%204%20L14%2018'/%3E%3C/svg%3E");
}
nav a.active {
  background-color: inherit;
  color: #fff;
}
a[itemprop="url"] {
  color: #ff9800;
}
a[itemprop="url"]:hover {
  color: #fff;
}
.muted, .help-block {
  opacity: 0.70;
}
.hack .muted,
.hack .help-block {
  color: #e0e0e0;
}
</style>
        


  
    <meta name="theme-color" content=#000>
  


      
    
  


    
    
      <script integrity="sha512-ISTAV0GadOIz/NXXHOS+eCM0ysXVVHhQTlvA6LJxz/DeA5yIxm0Vqf5IE+WH0yuuXkayAKtoZkQ326nch5f/fg==">fetchInject(["/css/syntax.css"]);</script>
      <noscript>
        <link href="/css/syntax.css" rel="stylesheet">
      </noscript>
    
  </head>
  
  
  
  <body class="hack dark main container">
    <header>
  

  
    
      
      
  <nav itemscope itemtype="https://schema.org/SiteNavigationElement">
    <meta itemprop="name" content="Main Menu">
    
      
      
        <a itemprop="url" href="/">Home</a>
      
    
      
      
        <a itemprop="url" href="/about-me/">About</a>
      
    
      
      
        <a itemprop="url" class="active" href="/post/">Posts</a>
      
    
      
      
        <a itemprop="url" href="/roguelikes/">Roguelike Development</a>
      
    
  </nav>


    
  


</header>
    <main>
  
    
      <style>{{ -}}.hack header figure[itemtype*=ImageObject]{position:relative}.hack header figure[itemtype*=ImageObject] figcaption{position:absolute;bottom:0;right:0;text-align:right;padding:15px;font-style:oblique;font-size:smaller;mix-blend-mode:soft-light}.hack header figure[itemtype*=ImageObject] [itemprop=headline]{font-weight:700}</style>
    
  
  <article itemscope itemtype="https://schema.org/BlogPosting">
    <meta itemprop="name" content="RoguelikeDev Builds a Roguelike, Part 4">
<meta itemprop="description" content="Part 4: A more interesting map">
<meta itemprop="datePublished" content="2017-07-11T13:41:06-06:00" />
<meta itemprop="dateModified" content="2017-07-11T13:41:06-06:00" />
<meta itemprop="wordCount" content="3772">
<meta itemprop="image" content="https://source.unsplash.com/collection/983219/2000x1322"/>



<meta itemprop="keywords" content="RLDBAR,go,programming,roguelike,cellular automata," />
    <header>
      <h1 itemprop="headline name">RoguelikeDev Builds a Roguelike, Part 4</h1>
      <p class="muted">
        <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <circle cx="16" cy="16" r="14" />
  <path d="M16 8 L16 16 20 20" />
</svg>
<span>18 minute read</span>
<svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z" />
</svg>

  Published: <time datetime="2017-07-11T13:41:06-06:00">11 Jul, 2017</time>


      </p>
      
        <blockquote itemprop="description">Part 4: A more interesting map</blockquote>
      
      



    </header>
    

    <div itemprop="articleBody">
      <p>Welcome to Part 4 of RoguelikeDev builds a Roguelike! This week, we&rsquo;re going to be fleshing out the map that the player will be playing the game on. If you recall, last time, we created an &lsquo;arena&rsquo; sort of map, with a large open space in the middle, surrounded by walls along the outside edges. Not very exciting, but it was something for the player to mover around in. This week, we&rsquo;re going to procedurally generate some (hopefully) realistic looking caverns that the player can explore. Certainly more exciting than a big empty room!</p>
<!-- more -->
<p>This week is all about making an interesting and dynamic map that the player can explore. One of the core tenants of Roguelikes is procedurally generated content, and one area where that is more noticeable is the game map. Every time the player plays our game, it would be awesome if their experience was different. We could certainly hardcode up some maps, and to be sure, there is value in that. But the real fun lies in random levels each and every time the game is played. Keeping true to this, we are going to code up a map generator that will be used whenever we need a new level of our dungeons (you can also extrapolate this concept out to any other map representation, overworld, buildings, etc). I&rsquo;ve decided that, rather than use the standard dungeon generator that the official tutorial uses, we&rsquo;re going to use a cellular automata algorithm to generate some nice looking caverns. I&rsquo;ll probably do the standard dungeon generator as a sidenote in the future.</p>
<p>First things first, before we dive into the meat of things, there are some convenience changes we&rsquo;ll want to make, to make our cartographical lives easier. First, I&rsquo;m going to add an (x, y) coordinate set to our Tile struct, and then I&rsquo;m going to add a couple methods that we will leverage quite a bit later down the line:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Tile</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Blocked</span> <span class="kt">bool</span>
    <span class="nx">Blocks_sight</span> <span class="kt">bool</span>
    <span class="nx">Visited</span> <span class="kt">bool</span>
    <span class="nx">X</span> <span class="kt">int</span>
    <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Tile</span><span class="p">)</span> <span class="nf">isWall</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Blocks_sight</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Blocked</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Tile</span><span class="p">)</span> <span class="nx">is</span> <span class="nf">Visited</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Visited</span>
<span class="p">}</span></code></pre></div>
<p>Aside from adding an (x, y) set to the Tile, I&rsquo;ve also added a Visited property. This will come in handy later when we need to check if we have already dealt with a Tile during map generation. The two convenience methods should be pretty self explanatory in their uses.</p>
<p>Alright, with that out of the way, lets do a quick refactor of some of our GameMap code:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">InitializeMap</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Initialize a two dimensional array that will represent the current game map (of dimensions Width x Height)
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="o">*</span><span class="nx">Tile</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">Tile</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Set a seed for procedural generation
</span><span class="c1"></span>	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">GenerateArena</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Generates a large, empty room, with walls ringing the outside edges
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span><span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">==</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span><span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Tile</span><span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Tile</span><span class="p">{</span><span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>As you can see, I broke out the actual map generation code from the initialize logic. Initialize now just creates an empty 2D array of Tiles (though none of the Tiles have been initialized yet, or even created). It also sets a seed for our randomization. More on that later.</p>
<p>Next, I broke our old map generation code into a new method, called GenerateArena(). This can be called on an initialized GameMap, and will create our familiar large room surrounded by walls. I&rsquo;m keeping this code around in case we want to create a map like this in the future.</p>
<p>Alright, with the little stuff out of the way, we&rsquo;ve paved the path forward to creating a new map generator. I&rsquo;m going to create a new function, attached to the Map struct, called GenerateCavern (public, as we&rsquo;ll want to call it outside of our map package):</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">GenerateCavern</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span></code></pre></div>
<p>The two ints that get returned will be a valid starting location for the player, so we can be sure it spawns in a valid location.</p>
<p>We&rsquo;re going to be using whats known as a cellular automata to generate our cave. Cellular automata are most famous from Conways game of Life. I&rsquo;m not going to get into that here, so Google it if you&rsquo;re curious. A cellular automata is essentially a way of representing &ldquo;cells&rdquo; or in our case, Tiles in the map. We will start by generating a random assortment of wall and floor Tiles. Then, we will check each Tile, and see if it should stay in its current state, or transition to the other state. In a traditional cellular automata, this would be called the cell living or dying, but we&rsquo;re going to frame as the Tile being a floor or a wall. We&rsquo;ll set our rules for each Tiles state such that if a wall tile is all by itself (no neighbors that are walls), perhaps it should not be a wall, and if a Tile is surrounded by walls, perhaps it too, should be a wall. This probably sounds a little esoteric, so lets just jump in, and I&rsquo;ll explain as we go (with pretty pictures!).</p>
<p>The first thing we need to do is fill up our empty 2D GameMap with a random assortment of Tiles:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Step 1: Fill the map space with a random assortment of walls and floors. This uses a roughly 40/60 ratio in favor
</span><span class="c1">// of floors, as I&#39;ve found that to produce the nicest results.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">state</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">state</span> <span class="p">&lt;</span> <span class="mi">50</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Tile</span><span class="p">{</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Tile</span><span class="p">{</span><span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>All this does, is loop over every element of the GameMap array, generate a random number between 0 and 100, and then give a 50% chance of creating a wall or floor Tile. The 50% is a very tweak-able percentage here, and I encourage you to play with it and see how it changes the overall outcome. I generally find that about 40% works best. Running our GenerateCavern() function should yield something like this:</p>
<p><img src="/static/week-2-step-1.png" alt="Cellular Automata, Step 1"></p>
<p>Again, tweak the percentage and see the changes. It will have a larger impact later, but for now, with a 50% chance, it covers roughly half the map with walls, and half with floor. This random looking mess is going to be the basis for our cavern.</p>
<p>Next up, we&rsquo;re going to go through each Tile we created in the previous step, and see if it should be a wall or a floor, based a couple of very simple rules. First, if 4 or more of the Tiles immediate neighbors are walls, or two or less neighbors up to 2 tiles away are walls, then that Tile becomes (or stays) a wall. If neither of those are true, the tile will become (or stay) a floor. Basically, going back to the cell analogy, if a cell is dead (floor), check to see if it has enough alive (wall) neighbors to be become alive again, and if a cell is alive (wall), check to ensure it has enough alive neighbors to remain alive.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Step 2: Decide what should remain as walls. If four or more of a tiles immediate (within 1 space) neighbors are
</span><span class="c1">// walls, then make that tile a wall. If 2 or less of the tiles next closest (2 spaces away) neighbors are walls,
</span><span class="c1">// then make that tile a wall. Any other scenario, and the tile will become (or stay) a floor tile.
</span><span class="c1">// Make several passes on this to help smooth out the walls of the cave.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">wallOneAway</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">countWallsNStepsAway</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>

			<span class="nx">wallTwoAway</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">countWallsNStepsAway</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>

			<span class="k">if</span> <span class="nx">wallOneAway</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="o">||</span> <span class="nx">wallTwoAway</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="p">{</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocked</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocks_sight</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocked</span> <span class="p">=</span> <span class="kc">false</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocks_sight</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Lets explain whats going on here. First up, we&rsquo;re going to make several passes over this code (5 to be precise). This will ensure that each time through, we &ldquo;smooth&rdquo; out the newly forming cavern a little bit more. This is also what will allow our cave formations to take shape. Any openings that are present after the first pass will be made more prominent in subsequent passes, as the algorithm tries to maintain groups of like Tiles.</p>
<p>Next, we set up a loop over every Tile in the GameMap, and call a new function, countWallsNStepsAway(). That function, which hopefully should be self explanatory from the name, looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">countWallsNStepsAway</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// Return the number of wall tiles that are within n spaces of the given tile
</span><span class="c1"></span>	<span class="nx">wallCount</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">r</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">n</span><span class="p">;</span> <span class="nx">r</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">r</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">n</span><span class="p">;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">c</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">r</span> <span class="o">&gt;=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">r</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">c</span> <span class="o">&gt;=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// Check if the current coordinates would be off the map. Off map coordinates count as a wall.
</span><span class="c1"></span>				<span class="nx">wallCount</span> <span class="o">++</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">r</span><span class="p">][</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c</span><span class="p">].</span><span class="nx">Blocked</span> <span class="o">&amp;&amp;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">r</span><span class="p">][</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">c</span><span class="p">].</span><span class="nx">Blocks_sight</span> <span class="p">{</span>
				<span class="nx">wallCount</span> <span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">wallCount</span>
<span class="p">}</span></code></pre></div>
<p>This function simply returns how many neighbors, n steps away from the provided Tile, are walls. We call that function twice, one for immediate (1 step away) neighbors, and once for neighbors two steps away. We then compare those returned values to the rules we laid out above. If it meets the criteria for neighbor walls, it becomes a wall, otherwise, we make it a floor. After one pass, our caverns look like this:</p>
<p><img src="/static/week-2-step2-1.png" alt="Cellular Automata, Step 2, 1"></p>
<p>And, after five passes, it looks like this:</p>
<p><img src="/static/week-2-step2-2.png" alt="Cellular Automata, Step 2, 5"></p>
<p>You can see how our algorithm has broken out multiple separate caverns, and has &ldquo;smoothed&rdquo; them out, getting rid of jagged edges and odd outcroppings that don&rsquo;t fit in their surroundings. Its actually starting to look like a proper set of caverns!</p>
<p>Next, we&rsquo;ll do a few more passes, but this time only looking for bits of wall that are by themselves, or extremely isolated among floor tiles (this will get rid of the walls that are standing out in the middle of the caverns by themselves):</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Step 3: Make a few more passes, smoothing further, and removing any small or single tile, unattached walls.
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">wallOneAway</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">countWallsNStepsAway</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>

			<span class="k">if</span> <span class="nx">wallOneAway</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">{</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocked</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocks_sight</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocked</span> <span class="p">=</span> <span class="kc">false</span>
				<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocks_sight</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>This pass is pretty simple, nothing new of note, aside from the slightly different wall rule. After five more passes of this, our cave now looks like this:</p>
<p><img src="/static/week-2-step3.png" alt="Cellular Automata, Step 3"></p>
<p>We&rsquo;ve now got some nice, smooth, artifact free caverns. The bottom edge of the screen looks a little ragged, but we&rsquo;ll clean that up in a minute. The next thing we&rsquo;re going to do is seal up the edges of the map, in case any of our caverns has an opening off the edge of the map. We don&rsquo;t want the player to be able to wander outside our designated map area:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Step 4: Seal up the edges of the map, so the player, and the following flood fill passes, cannot go beyond the
</span><span class="c1">// intended game area
</span><span class="c1"></span><span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span> <span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">==</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocked</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">].</span><span class="nx">Blocks_sight</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>This is straight-forward, we just go around the edges, and make every edge Tile a wall.</p>
<p><img src="/static/week-2-step4.png" alt="Cellular Automata, Step 4"></p>
<p>At this point, we&rsquo;ve got a bunch of small to large caverns, all nicely shaped, and very natural looking (I think so, at least :). However, the astute may have noticed that if the player were to spawn in one cavern, they would have no way of reaching any of the others (no digging in my roguelikes, not fond of the mechanic). So, how do we solve that? Well, the best way is to ensure there is only one main cavern. We could tunnel between each cavern, and run a few more passes of smoothing, but I actually like the idea of choosing the largest continuous cavern, and filling in the rest. That way, we ensure the player can reach every reachable part of the cavern they land in. The approach towards doing this also uses a neat algorithm called a flood fill, which we&rsquo;ll go over next.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Step 5: Flood fill. This will find each individual cavern in the cave system, and add them to a list. It will
</span><span class="c1">// then find the largest one, and will make that as the main play area. The smaller caverns will be filled in.
</span><span class="c1">// In the future, it might make sense to tunnel between caverns, and apply a few more smoothing passes, to make
</span><span class="c1">// larger, more realistic caverns.
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">cavern</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Tile</span>
<span class="kd">var</span> <span class="nx">totalCavernArea</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Tile</span>
<span class="kd">var</span> <span class="nx">caverns</span> <span class="p">[][]</span><span class="o">*</span><span class="nx">Tile</span>
<span class="kd">var</span> <span class="nx">tile</span> <span class="o">*</span><span class="nx">Tile</span>
<span class="kd">var</span> <span class="nx">node</span> <span class="o">*</span><span class="nx">Tile</span>

<span class="k">for</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">tile</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">]</span>

		<span class="c1">// If the current tile is a wall, or has already been visited, ignore it and move on
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">tile</span><span class="p">.</span><span class="nf">isVisited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">tile</span><span class="p">.</span><span class="nf">isWall</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// This is a non-wall, unvisited tile
</span><span class="c1"></span>			<span class="nx">cavern</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cavern</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">x</span><span class="p">][</span><span class="nx">y</span><span class="p">])</span>

			<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">cavern</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="c1">// While the current node tile has valid neighbors, keep looking for more valid neighbors off of
</span><span class="c1"></span>				<span class="c1">// each one
</span><span class="c1"></span>				<span class="nx">node</span> <span class="p">=</span> <span class="nx">cavern</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">cavern</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="nx">cavern</span> <span class="p">=</span> <span class="nx">cavern</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">cavern</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

				<span class="k">if</span> <span class="p">!</span><span class="nx">node</span><span class="p">.</span><span class="nf">isVisited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">node</span><span class="p">.</span><span class="nf">isWall</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// Mark the node as visited, and add it to the cavern area for this cavern
</span><span class="c1"></span>					<span class="nx">node</span><span class="p">.</span><span class="nx">Visited</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="nx">totalCavernArea</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">totalCavernArea</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>

					<span class="c1">// Add the tile to the west, if valid
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">X</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">X</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">node</span><span class="p">.</span><span class="nx">Y</span><span class="p">].</span><span class="nf">isWall</span><span class="p">()</span> <span class="p">{</span>
						<span class="nx">cavern</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cavern</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">X</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">node</span><span class="p">.</span><span class="nx">Y</span><span class="p">])</span>
					<span class="p">}</span>

					<span class="c1">// Add the tile to east, if valid
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Width</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">node</span><span class="p">.</span><span class="nx">Y</span><span class="p">].</span><span class="nf">isWall</span><span class="p">()</span> <span class="p">{</span>
						<span class="nx">cavern</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cavern</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nx">node</span><span class="p">.</span><span class="nx">Y</span><span class="p">])</span>
					<span class="p">}</span>

					<span class="c1">// Add the tile to north, if valid
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Y</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">X</span><span class="p">][</span><span class="nx">node</span><span class="p">.</span><span class="nx">Y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nf">isWall</span><span class="p">()</span> <span class="p">{</span>
						<span class="nx">cavern</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cavern</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">X</span><span class="p">][</span><span class="nx">node</span><span class="p">.</span><span class="nx">Y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
					<span class="p">}</span>

					<span class="c1">// Add the tile to south, if valid
</span><span class="c1"></span>					<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Height</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">X</span><span class="p">][</span><span class="nx">node</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="nf">isWall</span><span class="p">()</span> <span class="p">{</span>
						<span class="nx">cavern</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cavern</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Tiles</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">X</span><span class="p">][</span><span class="nx">node</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="c1">// All non-wall tiles have been found for the current cavern, add it to the list, and start looking for
</span><span class="c1"></span>			<span class="c1">// the next one
</span><span class="c1"></span>			<span class="nx">caverns</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">caverns</span><span class="p">,</span> <span class="nx">totalCavernArea</span><span class="p">)</span>
			<span class="nx">totalCavernArea</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">tile</span><span class="p">.</span><span class="nx">Visited</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Whoa, there&rsquo;s a lot going on there. Lets step through. First off, a flood fill algorithm is literally what it sounds like. It starts at a point, and will attempt to get each element nearby that shares a characteristic, while ignoring those that do not (flooding over an area until that area is filled). In our case, you can think of it like checking for an empty area (floor spaces), and expanding out, until it has found the maximum bounds of that area. At the end, we will have a list of all tiles in that area, and then the algorithm will move on, looking for the next open space that has not been checked yet.</p>
<p>We start out by defining a few variables, mainly slices to keep track of various things, like the current cavern, the size of the current cavern, and a list of all individual caverns we have found so far. Then, we begin by looping over every Tile element in our GameMap, and grabbing the Tile at each location. You&rsquo;ll notice I&rsquo;m using pointers for everything, including my slices. This makes it much easier, as we are dealing with the actual object, rather than a copy of it.</p>
<p>Once we have a Tile, we use our two new convenience methods from earlier to see if, a) have we already visited this Tile, and b) is this Tile a wall. If either of those are true, we mark this Tile visited, and move on. We keep track of Tiles we&rsquo;ve visited, so as not to double (or more) process them in the future. If a tile has not been visited, and is not a wall, we have found a Tile that is part of a cavern, so we add it to the cavern slice.</p>
<p>While there are Tiles present in the cavern slice, we will attempt to get every valid neighbor of each one. This is the flood in flood fill. Inside our cavern loop, we pop the latest Tile off the slice, make sure we don&rsquo;t have a visited or wall Tile once more, and then mark the Tile as visited (since we will not need to process it after this. We also push it onto the totalCavernArea slice, to keep track of Tiles in this current cavern. Then, we check each of its neighbors, north, south, east and west. If any of those are not visited and not walls, we add them to the current cavern. Then, we loop again, popping off a new Tile, and processing it in the same way.</p>
<p>In this way, we will eventually get every floor tile in the current cavern, and at the end, have a complete representation of that cavern in terms of the floor tiles that compose it. When we have exhausted (filled, to use the algorithms parlance) a cavern, we take that set of Tiles representing the cavern, and append it to the caverns slice, which is a slice of slices. Each sub slice in that slice represents a single complete cavern.</p>
<p>Once we are done here, we should have 12 entries in our caverns slice, one for each cavern present on our map. Keep in mind that you will have a different number.</p>
<p>Nice! We now have a comprehensive list of every cavern in our greater cavern system. At this point, you could do all sorts of neat things, but we&rsquo;re going to stick with our original plan, and fill in all but the largest cavern. This is pretty straight forward, but uses a new (to me at least) Go concept, sorting a slice.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Sort the caverns slice by size. This will make the largest cavern last, which will then be removed from the list.
</span><span class="c1">// Then, fill in any remaining caverns (aside from the main one). This will ensure that there are no areas on the
</span><span class="c1">// map that the player cannot reach.
</span><span class="c1"></span><span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nf">BySize</span><span class="p">(</span><span class="nx">caverns</span><span class="p">))</span>
<span class="nx">mainCave</span> <span class="o">:=</span> <span class="nx">caverns</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">caverns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="nx">caverns</span> <span class="p">=</span> <span class="nx">caverns</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">caverns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">caverns</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">caverns</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">caverns</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">].</span><span class="nx">Blocked</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">caverns</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">].</span><span class="nx">Blocks_sight</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>In order to sort our caverns slice, we&rsquo;ll need to define some custom logic. We want to sort it by the size of the sub slice, smallest to largest, so we can just pop off the last element of the slice, and be sure we have the largest cavern. In order to properly do this, we&rsquo;ll need to define a new type to sort by, called BySize:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BySize</span> <span class="p">[][]</span><span class="o">*</span><span class="nx">Tile</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">BySize</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">BySize</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">BySize</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
<span class="p">}</span></code></pre></div>
<p>Our new type is a 2D slice of Tile pointers, just like our caverns slice. We then define three functions attached to it, to allow for our comparisons. This code is all pretty self explanatory, so I&rsquo;ll leave it at that. Suffice it to say, that when we call sort.Sort() and pass in our new sorting type and our caverns array, it will return a neatly sorted array of caverns, from smallest to largest. Then, we simply just pull the largest cavern off the caverns array, and then systematically fill in the rest.</p>
<p>This leaves us with a single, connected cavern:</p>
<p><img src="/static/week-2-step-final.png" alt="Cellular Automata, final"></p>
<p>Now, all we need to do is place out player in a valid location within the main cave:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Finally, choose a starting position for the player within the newly created cave
</span><span class="c1"></span><span class="nx">pos</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">()</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mainCave</span><span class="p">)</span>
<span class="k">return</span> <span class="nx">mainCave</span><span class="p">[</span><span class="nx">pos</span><span class="p">].</span><span class="nx">X</span><span class="p">,</span> <span class="nx">mainCave</span><span class="p">[</span><span class="nx">pos</span><span class="p">].</span><span class="nx">Y</span></code></pre></div>
<p>And that&rsquo;s that. Lets call our new method in our main file, in our init function, so our cave will be the default map:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Create a GameMap, and initialize it (and set the player position within it, for now)
</span><span class="c1"></span><span class="nx">gameMap</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">gamemap</span><span class="p">.</span><span class="nx">Map</span><span class="p">{</span><span class="nx">Width</span><span class="p">:</span> <span class="nx">MapWidth</span><span class="p">,</span> <span class="nx">Height</span><span class="p">:</span> <span class="nx">MapHeight</span><span class="p">}</span>
<span class="nx">gameMap</span><span class="p">.</span><span class="nf">InitializeMap</span><span class="p">()</span>

<span class="nx">playerX</span><span class="p">,</span> <span class="nx">playerY</span> <span class="o">:=</span> <span class="nx">gameMap</span><span class="p">.</span><span class="nf">GenerateCavern</span><span class="p">()</span>
<span class="nx">player</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">playerX</span>
<span class="nx">player</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">playerY</span></code></pre></div>
<p>Now, when you fire up the game, you should have a sweet, random cave to explore every time! I would like to note that my cave in my example is a little lackluster, as it didn&rsquo;t generate the largest cave possible, but that&rsquo;s the beauty of procedural generation. I find that the caves are quite complex if done on a much bigger map. My example is 100x35, but here&rsquo;s some examples on a 200x200 map:</p>
<p><img src="/static/week-2-final1.png" alt="Cellular Automata, Complete1"></p>
<p>The variety it can create is pretty neat</p>
<p><img src="/static/week-2-final2.png" alt="Cellular Automata, Complete2"></p>
<p>I&rsquo;m generally pretty happy with the results</p>
<p><img src="/static/week-2-final3.png" alt="Cellular Automata, Complete3"></p>
<p>So, that&rsquo;s it, we now have an exciting map for our player to explore and get lost in. As I mentioned earlier, play around with various knobs on the algorithms (number of passes, percentages, ratios, etc), and see what works best. By tweaking a few small things, you can get drastically different results. As usual, if you want to see the full code for this post, you can find it in my <a href="https://github.com/jcerise/roguelikedev-does-the-complete-roguelike-tutorial/releases/tag/v0.0.5">repo</a></p>
<p>Be sure and join me next time when we&rsquo;ll be tackling field of vision, so not only can our player get lost, they can get lost in the cold, lonely, dark. Until next time, happy developing!</p>
<p><a href="/post/roguelike-dev-week-3-part-1/">This way to Week 5</a></p>

    </div>
    <footer>
      <hr>
      <p>
  Published
  
    
      by <span itemprop="author">Jeremy Cerise</span>
    
  
  <time itemprop="datePublished" datetime="2017-07-11T13:41:06-06:00">
    11 Jul, 2017
  </time>
  
    in <span itemprop="articleSection"><a href="/categories/technology/">technology</a></span>
  
  
    and tagged <a rel="tag" href="/tags/cellular-automata/">cellular automata</a>, <a rel="tag" href="/tags/go/">go</a>, <a rel="tag" href="/tags/programming/">programming</a>, <a rel="tag" href="/tags/rldbar/">RLDBAR</a> and <a rel="tag" href="/tags/roguelike/">roguelike</a>
  
  using <span itemprop="wordCount">3772</span> words.
</p>

      



  
    <aside>
      <header>Related Content</header>
      
        <ul>
          
            <li><a href="/post/sidenote-1-cameras/">RLDBAR Sidenote #1: Cameras</a>
            <time class="muted" datetime="9M">9 minutes</time>
          
            <li><a href="/post/roguelike-dev-week-1-part-2/">RoguelikeDev Builds A Roguelike, Part 3</a>
            <time class="muted" datetime="18M">18 minutes</time>
          
            <li><a href="/post/roguelike-dev-week-1-part-1/">RoguelikeDev Builds a Roguelike, Part 2</a>
            <time class="muted" datetime="8M">8 minutes</time>
          
            <li><a href="/post/roguelike-dev-week-0/">RoguelikeDev Builds a Roguelike, Part 1</a>
            <time class="muted" datetime="7M">7 minutes</time>
          
        </ul>
      
    </aside>
  


    </footer>
  </article>
</main>
    <footer>
  <small class="muted">
    
  
    Copyright &copy; Copyright Jermey Cerise. Licensed under <a target="_blank" rel="external noopener license" href="https://creativecommons.org/licenses/by-nd/4.0/">CC-BY-ND-4.0</a>.
  


  </small>
</footer>
    
    
    
      
    
  </body>
</html>
