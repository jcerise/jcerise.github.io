<div class="single">
  <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.15" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans|Marcellus+SC'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <link rel="stylesheet" href="http://jeremyceri.secss/styles.css">
    <link rel="stylesheet" href="http://jeremyceri.secss/custom.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://jeremyceri.se/index.xml">

    
    <title>Generating realistic (two dimensional) caverns with cellular automata - Jeremy Cerise</title>
    <meta property='og:title' content="Generating realistic (two dimensional) caverns with cellular automata - Jeremy Cerise">
    <meta property="og:type" content="article">
    

    <meta property="og:url" content="http://jeremyceri.se/post/cellular-automata-python/">
    
    <meta property="og:image" content="http://jeremyceri.seimages/cavern.jpg">

  </head>

  <body>

    <header class="site">
      <div class="title"><a href="http://jeremyceri.se">Jeremy Cerise</a></div>
      <div class="sub-title">Software Engineer, Web Developer, Professional Jack of All Trades</div>
    </header>

    <div class="container site">


  <div class="row">
    <div class="col-sm-9">

      <article class="single" itemscope="itemscope" itemtype="http://schema.org/Article">

        <meta itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" content="http://jeremyceri.se"/>
        <meta itemprop="dateModified" content="2013-02-20T18:01:29-06:00">
        <meta itemprop="headline" content="Generating realistic (two dimensional) caverns with cellular automata">
        <meta itemprop="description" content="I have been building a roguelike game in python for a while now. For those not familiar with this particular type of game, I will point you here. Basically, its, as my girlfriend put it, &ldquo;About the nerdiest thing you can possibly do with a computer&rdquo;. Opinions aside, roguelikes are very enjoyable to write, as I&rsquo;ve found, as you can focus solely on gameplay, and not worry about fancy rendering engines and lots of 3D math.">
        <meta itemprop="url" content="http://jeremyceri.se/post/cellular-automata-python/">
        <div itemprop="image" itemscope itemtype="https://schema.org/ImageObject">
          <meta itemprop="url" content="http://jeremyceri.seimages/cavern.jpg" />
          <meta itemprop="width" content="800">
          <meta itemprop="height" content="800">
        </div>
        <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
          <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <meta itemprop="url" content="http://jeremyceri.seimages/logo.jpg">
            <meta itemprop="width" content="100">
            <meta itemprop="height" content="100">
          </div>
          <meta itemprop="name" content="Jeremy Cerise">
        </div>
        <div itemprop="author" itemscope itemtype="https://schema.org/Person">
          <meta itemprop="name" content="Jeremy Cerise">
        </div>

        <div class="image" style="background-image: url(http://jeremyceri.seimages/cavern.jpg);"></div>

        <header class="article-header">
          <time itemprop="datePublished" pubdate="pubdate" datetime="2013-02-20T18:01:29-06:00">Wed, Feb 20, 2013</time>
          <h1 class="article-title">Generating realistic (two dimensional) caverns with cellular automata</h1>
        </header>

        <div class="article-body" itemprop="articleBody">
          <p>I have been building a roguelike game in python for a while now. For
those not familiar with this particular type of game, I will point you
<a href="http://en.wikipedia.org/wiki/Roguelike">here</a>.</p>

<p>Basically, its, as my
girlfriend put it, &ldquo;About the nerdiest thing you can possibly do with a
computer&rdquo;. Opinions aside, roguelikes are very enjoyable to write, as
I&rsquo;ve found, as you can focus solely on gameplay, and not worry about
fancy rendering engines and lots of 3D math.
<!--break-->
One of the staples of a roguelike is the dungeon generation algorithm.
Since 99% of a traditional roguelike is spent crawling through a dungeon
in search of monsters to slay and epic loot to pocket, its rather
important that the player is presented with an interesting series of
paths and environments to traipse through. Many roguelikes challenge the
player with navigating exclusively dungeon environments (straight
corridors, connecting rooms, which in turn are usually rectangular in
shape), and not much else. To be sure, my roguelike (<a href="https://github.com/jcerise/DungeonCrawler">DungeonCrawler</a>),
employs this formula, but I felt it lacked some variety. It gets tedious
constantly exploring the same environment over and over again. So, after
a little thought about what other types of subterranean labyrinth I
could throw at the player, I settled on caverns. Caverns present an
interesting challenge, as they need to look natural, which means no
straight lines, and also unpredictable corridors and rooms.</p>

<p>I ended up implementing a celluar automata algorithm to accomplish my
cavern building. Cellular automata, if you are unfamiliar, is the
concept behind Conways Game of Life. Basically, each tile in our cavern
can have one of two states: floor or wall. We start out by randomly
filling our entire map with tiles. I use the ratio of roughly 40% wall
tiles to 60% floor tiles (this tends to generate the nicest looking
results, in my experience).</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">42</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">blocked</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">block_sight</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div>


<p><img src="http://i.imgur.com/0IxpKNu.png"></p>

<p>As you can see, it looks pretty chaotic at this point. This will form
the basis for our cavern. For the record, brown tiles are floor, and
grey tiles are wall. The next step is to actually run our cellular
automata algorithm. I started out using the 4-5 rule (if a tile was a
wall and 4 or more of its neighbors are walls, it becomes a wall, or if
it was not a wall and 5 or more of its neighbors are walls). We pass
over each tile, and check its neighbors, and decide if it should be a
wall or a floor, based on the above stated criteria. The code to
accomplish this looks like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">])):</span>
            <span class="n">wall_count_one_away</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_walls_n_steps_away</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">wall_count_two_away</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_walls_n_steps_away</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wall_count_one_away</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="ow">or</span> <span class="n">wall_count_two_away</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1">#This tile becomes a wall</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">blocked</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">block_sight</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">blocked</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">block_sight</span> <span class="o">=</span> <span class="bp">False</span>
</code></pre></div>


<p>We make several passes like this, in my case 5. Each pass will smooth
out the cavern a little bit more, as the code decides, based on the
tiles neighbors, what each tile should be. If there are a lot of walls
around it, it should probably be a wall, and vice versa. Below you can
see the results of this after one pass (comapre it to our starting map
above):</p>

<p><img src="https://i.imgur.com/xSlEwfh.png"></p>

<p>And the results after 2 passes (these are obviously not the same map, I
had some trouble doing a step by step on one map, but it still
illustrates the idea all the same):</p>

<p><img src="https://i.imgur.com/noUAhsr.png"></p>

<p>As you can see, the cavern starts to take shape, as each tile is changed
to reflect the environment around it. Finally, after five passes, we end
up with this:</p>

<p><img src="https://i.imgur.com/JzBbeGQ.png"></p>

<p>After our five initial passes, I make 4 more using a slightly modified
algorithm. These passes mainly smooth out the caves a little more, and
get rid of any isolated walls or floor tiles that are left sitting in
the middle of nowhere:</p>

<p><div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">])):</span>
            <span class="n">wall_count_one_away</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_walls_n_steps_away</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wall_count_one_away</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
                <span class="c1">#This tile becomes a wall</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">blocked</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">block_sight</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">blocked</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">block_sight</span> <span class="o">=</span> <span class="bp">False</span>
</code></pre></div>
</p>

<p>After these last few iterations, our cave now looks like this:</p>

<p><img src="https://i.imgur.com/ESZxsK4.png"></p>

<p>At this point, we have a pretty nice, realistic looking cavern,
but you may notice that there is the potential for rooms that the player
cannot reach, and that are not connected to the main cavern. This is not
ideal, as the player is randomly placed in the cavern when the game
starts, and we do not want him to start in a small cavern not connected
to the main cavern.</p>

<p>To fix this problem, we need to identify each &lsquo;cavern&rsquo; that is part of
the larger cave complex. I define a &lsquo;cavern&rsquo; as a space that is not
connected to any other spaces. So, in the above example, there would be
five caverns, one main, large cavern, and then four smaller caverns
spread out around the edges. Once we have identified the individual caverns in our cave
system, we can then either connect them all (not ideal, as it looks
un-natural), or fill in all but the largest cavern (this is the approach
I take, as it maintains a realistic feel). First, how do we go about
identifying the various caverns that compose our cave system?</p>

<p>I used a flood fill algorithm to accomplish this. But, before we do
anything else, we need to seal up the edges of the map, so the player
cannot wander off the screen (my game does have scrolling maps yet, what
you see is the entire map). This is done as follows:</p>

<p><div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="c1">#Before we do anything else, we need to seal up the edges of the map, so the player cannot wander out into</span>
<span class="c1">#nothingness. We do this by walking around the edges of the map and making them all wall</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">block_sight</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">blocked</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div>
</p>

<p>Okay, now that we&rsquo;ve done that, lets get on to the floodfill algorithm.
The basic logic behind it is this: We loop through every tile on the map
checking for two things. First, have visited this tile already, and
second, is this tile a wall. If either of those is true, we ignore the
tile and move on. When we find a valid, unvisited, floor tile, we add
the tile to an array that will contain all tiles in the particular
cavern (we know we are in a cavern by the fact that this tile is floor).
Next, using our newly added cavern tile, we pop it off of the array, and
check all of its neighbors. If they are unvisited, and not a wall, they
are added to the cavern array. We run this sequence for each valid
neighbor, and each of their valid neighbors. When the array is finally
empty, we have exhausted all tiles in the current cavern, and now know
every tile that the cavern is composed of (when I pop the tile off the
cavern array, I push it onto a record keeping array, so we have record
of every tile in the cavern). At this point, all tiles in the current
cavern have been visited, so they will be ignored going forward. We
continue in this manner until all individual caverns in the cave system
have been mapped out. The code to accomplish this is as follows:</p>

<p><div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="c1">#Now, begin looping through the map, looking for individual caverns</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
        <span class="c1">#Grab the tile at the current coordinates</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>

        <span class="c1">#Set up some empty arrays to hold our current cavern</span>
        <span class="n">cavern</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_cavern_area</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#Ensure this is a non-wall tile that has not already been visited</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tile</span><span class="o">.</span><span class="n">visited</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tile</span><span class="o">.</span><span class="n">is_wall</span><span class="p">():</span>
            <span class="c1">#If it meets the criteria, add it to the new cavern</span>
            <span class="n">cavern</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>

            <span class="c1">#Loop through all potentially valid cavern tiles for this cavern, and see if they are actually part</span>
            <span class="c1">#of the cavern or not. If they are, add them to the total, and grab all four of their neighbors</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">cavern</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#Get the last item in the candidate list</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">cavern</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">visited</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_wall</span><span class="p">():</span>
                    <span class="c1">#Mark the tile as visited</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">total_cavern_area</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                    <span class="c1">#Append the tile to the west to the cavern array</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">is_wall</span><span class="p">():</span>
                        <span class="n">cavern</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">])</span>
                    <span class="c1">#Append the tile to the east to the cavern array</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">is_wall</span><span class="p">():</span>
                        <span class="n">cavern</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">node</span><span class="o">.</span><span class="n">y</span><span class="p">])</span>
                    <span class="c1">#Append the tile to the north to the cavern array</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_wall</span><span class="p">():</span>
                        <span class="n">cavern</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="c1">#Append the tile to the south to the cavern array</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_wall</span><span class="p">():</span>
                        <span class="n">cavern</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">x</span><span class="p">][</span><span class="n">node</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1">#Cavern detection and construction completed, so append this cavern to the list of all caverns</span>
            <span class="n">caverns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_cavern_area</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#This was not a valid cavern candidate, so mark it as visited so we dont bother with it again</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div>
</p>

<p>The caverns variable is a list off all detected individual caverns. So,
the end result is that we now know about every individual cavern on the
map, and can act on them accordingly. The next thing we do is to sort
the caverns by smallest to largest. This way, the largest cavern
(usually what we want to be the main cavern) will be last, and we can
remove it from the list of caverns. Since we are going to fill in all
but the main cavern, we want to ignore it, so removing it from the list
is the easiest and safest way to do this. Then, we simply fill in all
the remaining caverns:</p>

<p><div class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="c1">#Sort the cavern arrays so the largest cavern (the main cavern) is the last item, then remove it from the list</span>
<span class="c1">#All the remaining caverns will be filled in</span>
<span class="n">sorted_caverns</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">caverns</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">main_cave</span> <span class="o">=</span> <span class="n">sorted_caverns</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

<span class="c1">#Fill in each of the remaining caverns, as they are not part of the main cave. This will ensure that every</span>
<span class="c1">#part of the cavern system is accessible to the player</span>
<span class="k">for</span> <span class="n">cave</span> <span class="ow">in</span> <span class="n">sorted_caverns</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">cave</span><span class="p">:</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">blocked</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">block_sight</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div>
</p>

<p>And finally, we are left with one main cavern that player can reach
every part of:</p>

<p><img src="https://i.imgur.com/UWq6SQi.png"></p>

<p>Pretty nice, if I do say so myself. I&rsquo;ve included some more examples of
the final product below. Feel free to comment with any questions or
critiques in the comments below. I hope this has been helpful, or at the
very least midly interesting. YOu can also check out my roguelike in
progress on github <a href="https://github.com/jcerise/DungeonCrawler">here</a>, so
feel free to check out the code and give it a shot. I&rsquo;m also open to
pull request as well, if you feel so inclined.</p>

<p><img src="https://i.imgur.com/jQxDlsN.png"></p>

<p><img src="https://i.imgur.com/lrpak1g.png"></p>

<p><img src="https://i.imgur.com/hFMnSSk.png"></p>

        </div>


        <aside>
          <div class="section"><a href="http://jeremyceri.setags/Python" class="tag">Python</a> <a href="http://jeremyceri.setags/Game%20Development" class="tag">Game Development</a> <a href="http://jeremyceri.setags/Roguelike" class="tag">Roguelike</a> </div>

          <div class="section share">
            <a href="http://www.facebook.com/sharer.php?src=bm&u=http%3a%2f%2fjeremyceri.se%2fpost%2fcellular-automata-python%2f&t=Generating%20realistic%20%28two%20dimensional%29%20caverns%20with%20cellular%20automata" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-facebook"></i></a>
            <a href="http://twitter.com/intent/tweet?url=http%3a%2f%2fjeremyceri.se%2fpost%2fcellular-automata-python%2f&text=Generating%20realistic%20%28two%20dimensional%29%20caverns%20with%20cellular%20automata&tw_p=tweetbutton" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-twitter"></i></a>
            <a href="https://plus.google.com/share?url=http%3a%2f%2fjeremyceri.se%2fpost%2fcellular-automata-python%2f" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-google-plus"></i></a>
            <a href="http://getpocket.com/edit?url=http%3a%2f%2fjeremyceri.se%2fpost%2fcellular-automata-python%2f&title=Generating%20realistic%20%28two%20dimensional%29%20caverns%20with%20cellular%20automata" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-get-pocket"></i></a>
          </div>

          
          
          
        </aside>

      </article>
    </div>

    <div class="col-sm-3">
      <aside class="site">

  
  <div class="section">
    <header><div class="title">TableOfContents</div></header>
    <div class="list-default"></div>
  </div>
  

  
  <div class="section menu">
    <header><div class="title">Menu</div></header>

    
    <ul>
      
      <li>
        
      <li><a href="/about/"> About Me</a></li>
      
      
    </ul>
    

  </div>
  

  <div class="section">
    <header><div class="title">LatestPosts</div></header>
    <div class="content">
      
      <div class="sm"><article class="li">
  <a href="http://jeremyceri.se/about/" class="clearfix">
    <div class="image" style="background-image: url(http://jeremyceri.seimages/me.jpg);"></div>
    <div class="detail">
      <time>Tue, Mar 29, 2016</time>
      <h2 class="title">About Me</h2>
      <div class="summary">I am a software engineer. I program primarily in Python, Javascript, and whatever other languages strike my fancy (Kotlin, Scala, Rust, Erlang, etc). I also do other things, like miniature wargaming, downhill mountain biking, and video games. Sometimes I write about these things here. Contact me mail@jeremyceri.se Github: jcerise Twitter: jcerise</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://jeremyceri.se/post/haskell-list-comprehensions/" class="clearfix">
    <div class="image" style="background-image: url(http://jeremyceri.seimages/default.jpg);"></div>
    <div class="detail">
      <time>Tue, Mar 29, 2016</time>
      <h2 class="title">haskell list comprehensions</h2>
      <div class="summary">So, I&rsquo;ve recently been playing around with Haskell (for the second time, I started in on it a while back, but drifted away for one reason or another), and I&rsquo;ve been having a great time of it. I&rsquo;m just to the point where I&rsquo;m playing around with list comprehensions. List Comprehensions, for those not familiar, are basically the same as set comprehensions in mathematics. That is to say, they can be used to build lists out of other lists.</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://jeremyceri.se/post/learning-godot-part-one/" class="clearfix">
    <div class="image" style="background-image: url(http://jeremyceri.seimages/pong_score.png);"></div>
    <div class="detail">
      <time>Tue, Mar 29, 2016</time>
      <h2 class="title">Learning Godot: Extending the Pong Example</h2>
      <div class="summary">In my never-ending quest to build a game, I have recently started fiddling around with the Godot engine. Godot is, to draw a parallel (and possibly an unfair one at that), kind of an interesting mash up between GameMaker: Studio, and Unity. It can handle both 2D and 3D games, although it currently really shines for building 2D games. Its supports a relatively robust, and very Python-like scripting language. And, best of all, its open source.</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://jeremyceri.se/post/brief-history-pittsburg-colorado/" class="clearfix">
    <div class="image" style="background-image: url(http://jeremyceri.seimages/pittsburg.jpg);"></div>
    <div class="detail">
      <time>Fri, Mar 4, 2016</time>
      <h2 class="title">A brief history of Pittsburg, Colorado</h2>
      <div class="summary">Today, I took a short ski trip up to the ghost town of Pittsburg, and decided the town had an interesting enough history to warrant a quick post about its past. So, without further ado: The above is what Pittsburg looks today (with quite a bit of snow on the ground). No buildings left, and certainly nothing resembling a town. Nothing much at all, really, aside from some vacation homes (which are out of sight in this shot).</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://jeremyceri.se/post/cellular-automata-python/" class="clearfix">
    <div class="image" style="background-image: url(http://jeremyceri.seimages/cavern.jpg);"></div>
    <div class="detail">
      <time>Wed, Feb 20, 2013</time>
      <h2 class="title">Generating realistic (two dimensional) caverns with cellular automata</h2>
      <div class="summary">I have been building a roguelike game in python for a while now. For those not familiar with this particular type of game, I will point you here. Basically, its, as my girlfriend put it, &ldquo;About the nerdiest thing you can possibly do with a computer&rdquo;. Opinions aside, roguelikes are very enjoyable to write, as I&rsquo;ve found, as you can focus solely on gameplay, and not worry about fancy rendering engines and lots of 3D math.</div>
    </div>
  </a>
</article>
</div>
      
    </div>
  </div>

  
  <div class="section taxonomies">
    <header><div class="title">category</div></header>
    <div class="content">
      <a href="http://jeremyceri.secategories/programming">programming</a><a href="http://jeremyceri.secategories/tutorials">tutorials</a><a href="http://jeremyceri.secategories/godot-game-development">godot-game-development</a><a href="http://jeremyceri.secategories/history">history</a><a href="http://jeremyceri.secategories/colorado">colorado</a>
    </div>
  </div>
  
  <div class="section taxonomies">
    <header><div class="title">tag</div></header>
    <div class="content">
      <a href="http://jeremyceri.setags/game-development">game-development</a><a href="http://jeremyceri.setags/mining">mining</a><a href="http://jeremyceri.setags/ghost-town">ghost-town</a><a href="http://jeremyceri.setags/python">python</a><a href="http://jeremyceri.setags/haskell">haskell</a><a href="http://jeremyceri.setags/godot">godot</a><a href="http://jeremyceri.setags/history">history</a><a href="http://jeremyceri.setags/pittsburg">pittsburg</a><a href="http://jeremyceri.setags/game-design">game-design</a><a href="http://jeremyceri.setags/pong">pong</a>
    </div>
  </div>
  

</aside>

    </div>

  </div>

      </div>

    <footer class="site">
      <p>&copy; 2016 Jeremy Cerise</p>
      <p>Powered by <a href="http://gohugo.io" target="_blank" rel="nofollow">Hugo</a>, Theme <a href="https://github.com/dim0627/hugo_theme_robust" target="_blank" rel="nofollow">robust</a> designed by <a href="http://yet.unresolved.xyz" target="_blank" rel="nofollow">Daisuke Tsuji</a></p>
    </footer>

    <script src="//code.jquery.com/jquery-2.1.3.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    

  </body>
</html>

</div>
