<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>combat on Jeremy&#39;s Ramblings</title>
    <link>https://jeremyceri.se/tags/combat/</link>
    <description>Recent content in combat on Jeremy&#39;s Ramblings</description>
    <image>
      <title>combat on Jeremy&#39;s Ramblings</title>
      <link>https://jeremyceri.se/tags/combat/</link>
      <url>https://source.unsplash.com/collection/983219/2000x1322</url>
    </image>
    <ttl>1440</ttl>
    <generator>After Dark 9.2.2 (Hugo 0.68.3)</generator>
    <language>en-US</language>
    <copyright>Copyright &amp;copy; Copyright Jermey Cerise. Licensed under CC-BY-ND-4.0.</copyright>
    <lastBuildDate>Sat, 08 Aug 2020 05:33:43 UT</lastBuildDate>
    <atom:link href="https://jeremyceri.se/tags/combat/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RoguelikeDev Builds a Roguelike, Part 6</title>
      <link>https://jeremyceri.se/post/roguelike-dev-week-3-part-2/</link>
      <pubDate>Mon, 24 Jul 2017 04:20:22 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/roguelike-dev-week-3-part-2/</guid>
      <description>Welcome back to my series about building a Roguelike in Go (and following along with RoguelikeDev&amp;rsquo;s dev-along)! Last time, we added a field of vision algorithm to our game, putting the player in the dark, except the immediate area surrounding them. In this installment, we&amp;rsquo;re going to start adding the framework for monsters that inhabit the dark corners of the caverns. In particular, our goal will be to randomly place Game Entities, representing things such as Goblins, Troll, and Orcs, around our generated caverns, make sure they get to take actions, and allow the player to interact with them.</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[Welcome back to my series about building a Roguelike in Go (and following along with RoguelikeDev&amp;rsquo;s dev-along)! Last time, we added a field of vision algorithm to our game, putting the player in the dark, except the immediate area surrounding them. In this installment, we&amp;rsquo;re going to start adding the framework for monsters that inhabit the dark corners of the caverns. In particular, our goal will be to randomly place Game Entities, representing things such as Goblins, Troll, and Orcs, around our generated caverns, make sure they get to take actions, and allow the player to interact with them. We&amp;rsquo;ll be adding proper combat in a later post, but for now, lets add some monsters!
A pertinent question that we should ask, before we dive in, is how are we going to represent the monsters that will inhabit the depths of our caverns? You may recall that we have a struct for just such a thing: GameEntity. Our GameEntity struct is exactly what we need to create monsters. GameEntity&amp;rsquo;s sole purpose is to represent &amp;lsquo;things&amp;rsquo; in the game world, whether that be items, chests, NPCs, monsters, or the player. So far, we&amp;rsquo;ve only used the GameEntity struct to represent our player (and a short lived NPC), but now we&amp;rsquo;re going to start leveraging it much, much more.
We need to do some small additions to our GameEntity struct before we move forward. We&amp;rsquo;re going to add a name property, as well as property that indicates whether this entity blocks movement (in the exact same way that a Tile does):
type GameEntity struct { X int Y int Layer int Char string Color string Name string Blocks bool } Nothing fancy there, just a string and a bool.
Now that we have that additional data attached to our entities, lets put some thought into how we want to go about creating new monster entities, and adding them to our game world. The easiest approach to this, and the one we&amp;rsquo;re going to stick with for the time being, is to just randomly place some created entities around the map. There are a few challenges with this approach however: 1) We don&amp;rsquo;t want to place entities outside the bounds of where the player can go, and 2) we don&amp;rsquo;t want to place entities on top of one another. Lets setup the solution for the second issue first.
What we need is a way to see if there is a blocking entity at a given location. The way this should work is that, whenever we go to place an entity on our map, we will feed the intended coordinates into a function that checks the location of every entity currently placed, and make sure that one of them is not present at the location we are trying to use. This should be pretty easy to do, as we are also going to be keeping a (more or less) global list of entities that are present on the map. A logical place for this code to live in our entity package. This new function doesn&amp;rsquo;t need to be attached to the GameEntity struct, but from an organizational standpoint, it makes sense to put it in the same file:
func GetBlockingEntitiesAtLocation(entities []*GameEntity, destinationX, destinationY int) *GameEntity { // Return any entities that are at the destination location which would block movement 	for _, e := range entities { if e.Blocks &amp;amp;&amp;amp; e.X == destinationX &amp;amp;&amp;amp; e.Y == destinationY { return e } } return nil } We pass in a slice containing every entity currently present on the map, and the intended (x, y) coordinates for our new entity. We then check to see if there is an entity present, and if it blocks. If it does, we simply return that entity, or nil if nothing is present at the desired location.
Alright, we&amp;rsquo;ve now got a way to check valid entity locations, lets set about actually creating and placing a bunch of monster entities on our map!
At this point, I&amp;rsquo;ve decided to refactor my previous code a bit. We&amp;rsquo;re going to be dealing with map related functions (generating and placing monsters based on the type of map), so it makes sense that the monster generation and placement code lives in the gamemap package. Previously, I had one file, gamemap.go, which contained all the map logic. I decided, to keep things tidy, to break the gamemap.go file into three files: gamemap.go, which contains the core, common map logic; arena.go, which contains all code related to arena maps; and cavern.go, which contains all logic specific to caverns. You can look here to see the specifics of how this is now laid out. This is strictly an organizational change, so don&amp;rsquo;t feel obligated to follow my lead, if you don&amp;rsquo;t want to.
Anyways&amp;hellip;
We&amp;rsquo;re going to add a new function that will generate and place monsters in our cavern maps (I&amp;rsquo;m ignoring arenas, since that&amp;rsquo;s more for testing at the moment). Since we&amp;rsquo;re dealing with cavern maps, I&amp;rsquo;ve decided to call my function &amp;lsquo;populateCavern&amp;rsquo;. Lets look at the code, and I&amp;rsquo;ll explain it afterwards:
func populateCavern(mainCave []*Tile) []*entity.GameEntity { // Randomly sprinkle some Orcs, Trolls, and Goblins around the newly created cavern 	var entities []*entity.GameEntity var createdEntity *entity.GameEntity for i := 0; i &amp;lt; 2; i&#43;&#43; { x := 0 y := 0 locationFound := false for j := 0; j &amp;lt;= 50; j&#43;&#43; { // Attempt to find a clear location to create a mob (entity for now) 	pos := rand.Int() % len(mainCave) x = mainCave[pos].X y = mainCave[pos].Y if entity.GetBlockingEntitiesAtLocation(entities, x, y) == nil { locationFound = true break } } if locationFound { chance := rand.Intn(100) if chance &amp;lt;= 25 { // Create a Troll 	createdEntity = &amp;amp;entity.GameEntity{X: x, Y: y, Layer: 1, Char: &amp;#34;T&amp;#34;, Color: &amp;#34;dark green&amp;#34;, Blocks: true, Name: &amp;#34;Troll&amp;#34;} } else if chance &amp;gt; 25 &amp;amp;&amp;amp; chance &amp;lt;= 50 { // Create an Orc 	createdEntity = &amp;amp;entity.GameEntity{X: x, Y: y, Layer: 1, Char: &amp;#34;o&amp;#34;, Color: &amp;#34;darker green&amp;#34;, Blocks: true, Name: &amp;#34;Orc&amp;#34;} } else { // Create a Goblin 	createdEntity = &amp;amp;entity.GameEntity{X: x, Y: y, Layer: 1, Char: &amp;#34;g&amp;#34;, Color: &amp;#34;green&amp;#34;, Blocks: true, Name: &amp;#34;Goblin&amp;#34;} } entities = append(entities, createdEntity) } else { // No location was found after 50 tries, which means the map is quite full. Stop here and return. 	break } } return entities } populateCavern() takes a list of Tiles called mainCave. You may remember from the post on map generation that our cavern generation algorithm keeps track of the main cave area used during the final steps of the process. We&amp;rsquo;re going to pass that slice into our populateCavern() function, as it contains a list of all clear, non-wall Tiles in the playable area, which is exactly what we need.
We start off by creating a for loop. This outer loop will determine how many monsters we generate. I&amp;rsquo;ve set mine to 2, but you can tweak that value to your liking. Next, we step into an inner loop, that runs no more than 50 times. This loop is going to attempt to find a valid, clear location for our new (yet to be created) monster. The reason for this loop is simple: we are going to randomly generate coordinates within our cavern, and then check if it is a clear (no blocking entity present) location. If it is not, we will iterate, and try again, with a new set of random coordinates. We will keep looping and looking until a valid location is found. If the loop runs for more than 50 iterations, its pretty safe to assume that there are no valid locations left, and the loop should break. This will prevent our game from endlessly looking for a valid location, when one may not even exist.
The location checker loop is pretty straight forward. We grab a random position within the mainCave, and get the (X, Y) values from the Tile at that location. We then use our new GetBlockingEntitiesAtLocation() function, passing in the randomly generated (x, y) coordinates. If that function returns nil, we have found a valid location, and we set the locationFound variable to true, and break out of the loop. If no valid location is found, we try again. If all 50 iterations are used up, the loop will end, with locationFound still having a value of false.
Next, if a location was in fact found, we generate a random number between 1 and 100. This will give us a 25% chance of creating a Troll, a 25% chance of creating an Orc, and a 50% chance of creating a Goblin. We then create the appropriate entity, using our new name and blocks properties.
Finally, we append the newly created entity onto the local entities slice, which will be returned.
We&amp;rsquo;ve now got some entities, in valid locations, for our map. Lets quickly look at the code in GenerateCavern() that calls this new function:
func (m *Map) GenerateCavern() (int, int, []*entity.GameEntity) { ... // Populate the cavern with some nasty critters 	entities := populateCavern(mainCave) // Finally, choose a starting position for the player within the newly created cave 	pos := rand.Int() % len(mainCave) return mainCave[pos].X, mainCave[pos].Y, entities } You can see I&amp;rsquo;ve changed the signature a bit, as GenerateCavern() now returns a slice of GameEntity, alongside the valid coordinates for the player. Beyond that, we simply call the populateCavern() function, and assign the slice of returned entities to the &amp;lsquo;entities&amp;rsquo; variable, and then return that alongside the players (x, y) position.
Finally, lets get those entities drawn to the screen! Back in our main file, in our init() function, we&amp;rsquo;re going to add a small update:
func init() { ... playerX, playerY, mapEntities := gameMap.GenerateCavern() player.X = playerX player.Y = playerY entities = append(entities, mapEntities...) ... } We&amp;rsquo;re now grabbing the returned GameEntity slice from our GenerateCavern() function. Earlier, we created a slice called entities (of which our player is a part) that was intended to contain every entity currently on the map. Here, we are simply appending the mapEntities slice to the (sort of) global entities slice. This will ensure that our entities from our map generation get drawn correctly, along side our player, each turn!
(You may notice that there is console output on my game. This is the topic of an upcoming SideNote, so stay tuned if that interests you.)
We&amp;rsquo;ve successfully generated, placed, and drawn several (not yet) threatening monsters onto our game map. But&amp;hellip;they don&amp;rsquo;t really do much, and if the player attempts to interact with them, you&amp;rsquo;ll find you can walk right through them as if they&amp;rsquo;re not even there. These are some cut-rate monsters&amp;hellip; Lets fix that!
As it stands right now, the player takes an action (currently only moving is implemented), and then is allowed to take another action, and another, and another, ad nauseum. We need a way to let the monsters take a turn, after the player has done something. Essentially, we are going to consider one action by the player to be his turn. So, the player moving north one Tile, or the player drinking a potion, or resting, these are all actions that would end the players turn. Once the player has acted, we want to let the monsters on the map do something as well. We&amp;rsquo;re going to need some way of keeping track of the current turn, or game state.
Lets do that first. We&amp;rsquo;ll create a couple of new constants, one called PlayerTurn, and one called MobTurn. What we&amp;rsquo;re aiming for is basically an enum that we can reference to check or set the current state of the game, the players turn, or the monsters turn. Since Go doesn&amp;rsquo;t have direct support for an enum type, I&amp;rsquo;m going to use a language feature called &amp;lsquo;iota&amp;rsquo;. The iota keyword will auto-increment its value each time we call it, meaning that if we call it three times in sequence, each call will have a value of (1 &#43; last_iota_value). This is super handy for creating enum like variable sets:
const ( WindowSizeX = 100 WindowSizeY = 35 MapWidth = 100 MapHeight = 35 Title = &amp;#34;BearRogue&amp;#34; Font = &amp;#34;fonts/UbuntuMono.ttf&amp;#34; FontSize = 24 PlayerTurn = iota MobTurn = iota ) Now, I&amp;rsquo;m going to set a new variable called gameTurn:
var ( player *entity.GameEntity entities []*entity.GameEntity gameMap *gamemap.Map gameCamera *camera.GameCamera fieldOfView *fov.FieldOfVision gameTurn int ) Finally, in our init() function, we&amp;rsquo;re going to set the gameTurn to the player:
func init() { ... // Set the current turn to the player, so they may act first 	gameTurn = PlayerTurn ... } The gameTurn variable will regularly get flipped from state to state. Once the player takes an action, it flips to MobTurn, and the monsters all get to take one action. Once they are done, it will flip back to PlayerTurn, etc. This sets up a nice turn by turn flow for the game, with every entity getting one action per turn.
Now, in our main game loop, we need to implement that logic. Turns out, its pretty simple:
func main() { ... if key != blt.TK_CLOSE { if gameTurn == PlayerTurn { handleInput(key, player) } } else { break } if gameTurn == MobTurn { for _, e := range entities { if e != player { if gameMap.Tiles[e.X][e.Y].Visible { // Check to ensure that the entity is visible before allowing it to message the player 	// This will change soon, as entities will act whether the player can see them or not. 	fmt.Printf(&amp;#34;The %s waits patiently...&amp;#34;, e.Name) } } } gameTurn = PlayerTurn } ... } When we check for player input, we also check to see if it is in fact the players turn. If it is, we allow the input to be processed. If not, we skip over the action and continue. If it is the players turn, we call handleInput as normal, but there&amp;rsquo;s one small change in there:
func handleInput(key int, player *entity.GameEntity) { ... // Check to ensure that the tile the player is trying to move in to is a valid move (not blocked) 	if !gameMap.IsBlocked(player.X &#43; dx, player.Y &#43; dy) { target := entity.GetBlockingEntitiesAtLocation(entities, player.X &#43; dx, player.Y &#43; dy) if target != nil { fmt.Printf(&amp;#34;You harmlessly bump into the %s&amp;#34;, target.Name) } else { player.Move(dx, dy) } } // Switch the game turn to the Mobs turn 	gameTurn = MobTurn } After we check if the desired location is blocked, we also check to see if there is a blocking entity present. If there is, we stop the movement, similar to how we stop movement into a wall, and print a message letting the player know that they have bumped into something nasty. Finally, we switch the game turn to the monsters.
Back in the main game loop, we check if its the monsters turn. If it is, we loop (naively right now, we&amp;rsquo;ll make this better later) through every entity on the map, being sure to skip the player, and let them take an action. Right now that action consists of printing out that its waiting patiently, but later this will be things like moving, attacking, etc.
And that&amp;rsquo;s it! If you fire up the game now, you should be able to find some monsters, which should act in reaction to your movement, and allow you to harmlessly bump into them.
This has laid the groundwork for our upcoming combat system. We&amp;rsquo;ve allowed the player to interact with other entities, a theme we&amp;rsquo;re going to continue to develop, as its one of the core mechanics of the game. We also set up a system to randomly fill our caves and dungeons with all sorts of nasty creatures, just waiting to hassle the player.
As usual, if you want to see the code for this post, you can find it here. Next time, we&amp;rsquo;ll be fleshing out the combat system, and adding some nice GUI components. Until then, happy developing!
This way to Part 7: ECS Refactor
]]></content:encoded>
    </item>
  </channel>
</rss>
