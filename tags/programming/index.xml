<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>programming on Jeremy&#39;s Ramblings</title>
    <link>https://jeremyceri.se/tags/programming/</link>
    <description>Recent content in programming on Jeremy&#39;s Ramblings</description>
    <image>
      <title>programming on Jeremy&#39;s Ramblings</title>
      <link>https://jeremyceri.se/tags/programming/</link>
      <url>https://source.unsplash.com/collection/983219/2000x1322</url>
    </image>
    <ttl>1440</ttl>
    <generator>After Dark 9.2.2 (Hugo 0.68.3)</generator>
    <language>en-US</language>
    <copyright>Copyright &amp;copy; Copyright Jermey Cerise. Licensed under CC-BY-ND-4.0.</copyright>
    <lastBuildDate>Sat, 08 Aug 2020 05:33:43 UT</lastBuildDate>
    <atom:link href="https://jeremyceri.se/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RoguelikeDev Builds a Roguelike, Part 7</title>
      <link>https://jeremyceri.se/post/roguelike-dev-part-7/</link>
      <pubDate>Fri, 28 Jul 2017 04:58:00 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/roguelike-dev-part-7/</guid>
      <description>The time has finally come where our small game is going to become unmanageable when adding new features. Certainly, we could make it work (and in fact the official tutorial and revamped tutorial come up with some clever ways around this complexity), but I&amp;rsquo;m not a fan of headaches, or unmaintainable code. I&amp;rsquo;ve always wanted to write an entity component system setup from scratch, to better understand how they work, and and ECS can dramatically help us cut down on complexity of new features.</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[The time has finally come where our small game is going to become unmanageable when adding new features. Certainly, we could make it work (and in fact the official tutorial and revamped tutorial come up with some clever ways around this complexity), but I&amp;rsquo;m not a fan of headaches, or unmaintainable code. I&amp;rsquo;ve always wanted to write an entity component system setup from scratch, to better understand how they work, and and ECS can dramatically help us cut down on complexity of new features. So, that&amp;rsquo;s the route we&amp;rsquo;re going to take. A bit of warning in advance, I have no experience with ECS whatsoever, so this should be exciting! Lets get to it!
A bit of background first. At this point in our development cycle, we are about to start adding some more complex features to our game. Namely, actual combat, and monsters etc that the player will be fighting. Beyond that, we&amp;rsquo;re also going to be soon adding support for items (consumable, equip-able, and otherwise). These two features on their own warrant a large amount of thought into how we are going to implement them. At this point, the official tutorial that RLDBAR is following takes the most obvious, and probably easiest to understand route of classic inheritance. Using this model, we could create a base Entity class (which we have already done), that contains a few common attributes that every entity in the game should have, things like name, character, color, HP, position, etc. Then, from this base entity class, we could create more specialized entity types, to say represent a Goblin. The Goblin entity would have all the base entity attributes, alongside some specific to a Goblin. From there, we could create an even more specific version of a Goblin, say a Goblin Chief, which would inherit all the base attributes of an entity, along with the attributes of a Goblin. Eventually, you can see how this would lead to quite a complex chain of inheritance, and a large number of classes. In some cases, we might even be tempted to use multiple inheritance (if the language supports it), which can lead to all sorts of problems, the least of which is confusing code.
Inheritance is certainly one way to solve this problem, but there must be a better way. The old idiom &amp;ldquo;composition over inheritance&amp;rdquo; immediately comes to mind. Rather than have an inheritance based system, what if we could use composition to create out entities? Basically, writing a bunch of smaller components that we can then attach to an entity, to describe how it should behave at any given time; sounds like a good approach. Turns out, this is a pretty common game design pattern, called Entity Component System. Using Entity Component System (henceforth known as ECS), we can define a base entity, which will be as simple as possible (literally just an ID, and a list of components), and then attach components to it (which themselves are just a collection of attributes). We will then write a series of systems that act upon the various components for each entity.
Using this setup, we can create any combination of entity imaginable. Say we want to create the Goblin from earlier. Previously, this involved creating a new class that inherited from Entity. Now, we can just create a new entity, and attach the appropriate components to it (appearance, position, movement, hitpoints, attacker, killable, and a basic AI component). If we wanted to make a Goblin Chief, we would simply create a new entity with the same components attached as the base goblin, but with maybe a more advanced AI, to represent the greater threat it poses. Similarly, we could also use this system to create items (an entity with an equip-able component, and an attackStats component, along with an appearance and position, could represent an axe found on the floor. A chest could be an entity with openable, inventory, and breakable components). Hopefully these examples aren&amp;rsquo;t too contrived, and you can understand the power of a system like this.
We&amp;rsquo;ll use a series of systems to tie this all together. Our systems will be small chunks of logic that check if the appropriate components are present on an entity, and if so, will act upon them accordingly. A movement system might check for the movement component, alongside position and appearance, and if those are present, adjust the x and y coordinates in the position component to represent the entity moving around the map.
To summarize, an entity is a small container with an ID, and a list of components. A component contains no logic, just data, and can optionally just be a flag (contains no data, it will simply be present or not). A system contains the logic for a specific component or set of components.
A quick note, there are a number of implementations of ECS out there (most notably, at least to me, is Artemis). I&amp;rsquo;ve decided to roll my own, both to help me understand how they work, and also simply because I didn&amp;rsquo;t find a good pre-built solution for Go :p
So, now that we have a basic idea of what an ECS is, and generally how they work, lets start looking at how to shoehorn one into our game in progress. We&amp;rsquo;ve got a bit of work to do, as this is a pretty major refactor. We&amp;rsquo;ve already got an Entity struct that we can leverage, but its currently tracking way too much data. That&amp;rsquo;s going to be where we&amp;rsquo;ll start, cutting the fat in our Entity class to better match our goal. Before we get to the code, I&amp;rsquo;m going to refactor our ecs package a bit. It will now have three main files, entity.go, components.go, and systems.go. Hopefully, each of these should be obvious as to their contents. Lets start by looking at our new, skinny entity struct:
type GameEntity struct { gmUUID uuid.UUID Components map[string]Component mux sync.Mutex } As you can see, we&amp;rsquo;ve eliminated all but two fields (plus a mutex field, but thats beyond the scope of this post, and can be safely ignored). gmUUID is a guid that we generate for each new entity we create. Components is a map of components (indexed by the components name). And that&amp;rsquo;s it. I&amp;rsquo;m also going to outline some convenience methods attached to this struct that will make our lives easier later:
func (e *GameEntity) HasComponent(componentName string) bool { // Check to see if the entity has the given component 	if _, ok := e.Components[componentName]; ok { return true } else { return false } } func (e *GameEntity) HasComponents(componentNames []string) bool { // Check to see if the entity has the given components 	containsAll := true if e != nil { for i := 0; i &amp;lt; len(componentNames); i&#43;&#43; { if !e.HasComponent(componentNames[i]) { containsAll = false } } } else { return false } return containsAll } func (e *GameEntity) AddComponent(name string, component Component) { // Add a single component to the entity 	e.Components[name] = component } func (e *GameEntity) AddComponents(components map[string]Component) { // Add several (or one) components to the entity 	e.mux.Lock() for name, component := range components { if component != nil { //fmt.Printf(&amp;#34;Adding component: %s - %v\n&amp;#34;, name, component) 	e.Components[name] = component } } e.mux.Unlock() } func (e *GameEntity) RemoveComponent(componentName string) { // Remove of a component from the entity 	_, ok := e.Components[componentName] if ok { delete(e.Components, componentName) } } func (e *GameEntity) RemoveComponents(componentNames []string) { e.mux.Lock() for i := 0; i &amp;lt; len(componentNames); i&#43;&#43; { _, ok := e.Components[componentNames[i]] if ok { delete(e.Components, componentNames[i]) } } e.mux.Unlock() } func (e *GameEntity) GetComponent(componentName string) Component { // Return the named component from the entity, if present 	if _, ok := e.Components[componentName]; ok { return e.Components[componentName] } else { return nil } } These functions should be pretty self explanatory, so I&amp;rsquo;ll leave their descriptions brief. Basically, these are just ways to check if the entity has a given component (or list of components), add a component to the entity (or a list of components), and removing a component from the entity (or a list of components). All in all, our entity sturct is pretty simple.
Next, we&amp;rsquo;re going to define an interface that will encompass all of our created components. Interfaces in Go work in a very simple fashion. An interface defines function definitions, and any struct that implements all of those definitions is said to be of that interface. The reason we&amp;rsquo;re doing it this way, is because we are going to want a generic (Go doesn&amp;rsquo;t support proper generics) way of putting a component (of many different types) onto an entity. Implementing the interface on all of our components will make them all &amp;ldquo;generic&amp;rdquo; components, in addition to their actual type, making it much easier for us to attach, detach, and check for them on entities. The following code is in components.go:
type Component interface { IsAIComponent() bool } Very basic. We define one function signature, IsAIComponent(), that will be true if the component is an AI component, and false otherwise. This will make a little more sense in a bit. All of our components will have this function attached, and therefore will be a Component.
We&amp;rsquo;re now going to define a few basic components that most of our entities will have:
/ Player Component type PlayerComponent struct { } func (pl PlayerComponent) IsAIComponent() bool { return false } // Position Component type PositionComponent struct { X int Y int } func (pc PositionComponent) IsAIComponent() bool { return false } // Appearance Component type AppearanceComponent struct { Color string Character string Layer int Name string } func (a AppearanceComponent) IsAIComponent() bool { return false } Lets go through these one by one. First up is the PlayerComponent(). This is what I&amp;rsquo;m going to refer to as a flag component. The PlayerComponent struct doesn&amp;rsquo;t have any data associated with it. This type of component simply indicates a state on the entity it is attached to. In this, it indicates that the entity is the player. Obviously, only one entity in the game will have this component (although their may be states in the future where this is not true, that&amp;rsquo;s the beauty of the flexibility of ECS).
Next, we have a PositionComponent. This component has an x and a y field. This will, unsurprisingly, represent where an entity is in the game world. Any entity that is active on the map will have this component.
AppearanceComponent means that an entity has a physical representation on the map. It has a color, character, layer, and name, all things that allow us to display it the player. If an entity doesn&amp;rsquo;t have an AppearanceComponent, it won&amp;rsquo;t be shown at all (we&amp;rsquo;ll be altering the state of this component when an entity is killed, to represent their newly corpse like appearance).
This should give a good overview of what components are, and the general idea of how I am defining them. Keeping this simple is the name of the game.
Now that we&amp;rsquo;ve got our new entity and component definitions all squared away, lets see how we can actually use them. The first thing I&amp;rsquo;m going to do is re-define our player entity. You may remember, previously, we have been creating our player entity by defining a list of values for various attributes on the entity itself. Now that we have our new system in place, this will look a bit different.
This is in our init() function, in our main file:
// Create a player Entity, and add them to our slice of Entities player = &amp;amp;ecs.GameEntity{} player.AddComponent(&amp;#34;player&amp;#34;, ecs.PlayerComponent{}) player.AddComponent(&amp;#34;position&amp;#34;, ecs.PositionComponent{X: 0, Y: 0}) player.AddComponent(&amp;#34;appearance&amp;#34;, ecs.AppearanceComponent{Color: &amp;#34;white&amp;#34;, Character: &amp;#34;@&amp;#34;, Layer: 1, Name: &amp;#34;Player&amp;#34;}) player.AddComponent(&amp;#34;movement&amp;#34;, ecs.MovementComponent{}) player.AddComponent(&amp;#34;controllable&amp;#34;, ecs.ControllableComponent{}) This is how we&amp;rsquo;re going to define entities from here out. All we&amp;rsquo;re doing is adding a list of components to the newly created entity. Each component has a name, and a component type. You may notice that there are some components here that I have not previously discussed, movement and controllable. You&amp;rsquo;ll notice these are both flag components, as they take no data. These indicate that the player is directly controllable using the keyboard, and that it is capable of movement.
I&amp;rsquo;m setting the players position component to values of X: 0 and Y:0. This is because we generate the starting coordinates for the player from the map, if you recall. Lets see how setting that has changed:
if player.HasComponent(&amp;#34;position&amp;#34;) { positionComponent, _ := player.Components[&amp;#34;position&amp;#34;].(ecs.PositionComponent) positionComponent.X = playerX positionComponent.Y = playerY player.RemoveComponent(&amp;#34;position&amp;#34;) player.AddComponent(&amp;#34;position&amp;#34;, positionComponent) } First, we check to make sure the player actually has a PositionComponent (this is a pattern we will repeat much in the near future). If it does, we grab the PositionComponent (using a type assertions to ensure Go that are actually pulling a PositionComponent), and then we set it to the x and y value from our map generation code. Then, we remove the existing PositionComponent, and replace it with our updated one (as we are not using pointers for the components). That&amp;rsquo;s it, our player now has an updated PositionComponent, and will be reflected in that position when we draw it to the screen.
Speaking of rendering, our renderEntities() function will need a bit of an overhaul, now that we cannot directly access properties on each entity. In fact, we&amp;rsquo;re going to completely remove renderEntities(), and replace it with our first system. We&amp;rsquo;re going to create a new system, called SystemRender(). This system will take the master list of entities (unchanged through our refactor, we&amp;rsquo;re still keeping track of them the same way), and render those who have a position and appearance component. This system will live in our systems.go file:
func SystemRender(entities []*GameEntity, camera *camera.GameCamera, gameMap *gamemap.Map) { // Render all renderable entities to the screen 	for _, e := range entities { if e != nil { if e.HasComponents([]string{&amp;#34;position&amp;#34;, &amp;#34;appearance&amp;#34;}) { pos, _ := e.Components[&amp;#34;position&amp;#34;].(PositionComponent) app, _ := e.Components[&amp;#34;appearance&amp;#34;].(AppearanceComponent) cameraX, cameraY := camera.ToCameraCoordinates(pos.X, pos.Y) if gameMap.Tiles[pos.X][pos.Y].Visible { blt.Layer(app.Layer) blt.Color(blt.ColorFromName(app.Color)) blt.Print(cameraX, cameraY, app.Character) } } } } } This code should look sort of familiar, as at its core, its no different than our previous rendering code. The main difference lies in how we&amp;rsquo;re accessing the appearance and position information. Whereas previously, we would pull that information directly off the entity, we now pull it off of the entities components (if they are present). We first check each entity to make sure it is valid for this system (has a position and appearance), then we grab those components (again, using a type assertion on each). WE then use the information on each to draw the entity to the screen in the same manner we always have.
Now that we&amp;rsquo;ve got that fancy new system sitting there, ready to go, where and how do we call it? The answer is, just like our old renderEntities function, and in roughly the same place. Back in our main game file, in our main() function:
func main() { // Main game loop  messageLog.SendMessage(&amp;#34;You find yourself in the caverns of eternal sadness...you start to feel a little more sad.&amp;#34;) messageLog.PrintMessages(ViewAreaY, WindowSizeX, WindowSizeY) renderMap() ecs.SystemRender(entities, gameCamera, gameMap) ... renderMap() ecs.SystemRender(entities, gameCamera, gameMap) messageLog.PrintMessages(ViewAreaY, WindowSizeX, WindowSizeY) } blt.Close() } That should look pretty familiar. Really, all we&amp;rsquo;ve done is replace the old call to RenderAll() (which called RenderEntities()) with a call to our new system function, passing in the entities, gameCamera, and gameMap. That&amp;rsquo;s all. Nothing crazy here. Every time through our game loop, SystemRender() will be called, it will check each entity for the proper components, and, if present, render the entity to the screen.
One last thing we need to do is replace our monster generation with our ECS setup. This will be in cavern.go, in the gamemap package:
if chance &amp;lt;= 25 { // Create a Troll 	createdEntity = &amp;amp;ecs.GameEntity{} createdEntity.SetupGameEntity() createdEntity.AddComponents(map[string]ecs.Component{&amp;#34;position&amp;#34;: ecs.PositionComponent{X: x, Y: y}, &amp;#34;appearance&amp;#34;: ecs.AppearanceComponent{Layer: 1, Character: &amp;#34;T&amp;#34;, Color: &amp;#34;dark green&amp;#34;, Name: &amp;#34;Troll&amp;#34;}, &amp;#34;hitpoints&amp;#34;: ecs.HitPointComponent{Hp: 20, MaxHP: 20}, &amp;#34;movement&amp;#34;: ecs.MovementComponent{}}) } else if chance &amp;gt; 25 &amp;amp;&amp;amp; chance &amp;lt;= 50 { // Create an Orc 	createdEntity = &amp;amp;ecs.GameEntity{} createdEntity.SetupGameEntity() createdEntity.AddComponents(map[string]ecs.Component{&amp;#34;position&amp;#34;: ecs.PositionComponent{X: x, Y: y}, &amp;#34;appearance&amp;#34;: ecs.AppearanceComponent{Layer: 1, Character: &amp;#34;o&amp;#34;, Color: &amp;#34;darker green&amp;#34;, Name: &amp;#34;Orc&amp;#34;}, &amp;#34;hitpoints&amp;#34;: ecs.HitPointComponent{Hp: 15, MaxHP: 15}, &amp;#34;movement&amp;#34;: ecs.MovementComponent{}}) } else if chance &amp;gt; 50 { // Create a Goblin 	createdEntity = &amp;amp;ecs.GameEntity{} createdEntity.SetupGameEntity() createdEntity.AddComponents(map[string]ecs.Component{&amp;#34;position&amp;#34;: ecs.PositionComponent{X: x, Y: y}, &amp;#34;appearance&amp;#34;: ecs.AppearanceComponent{Layer: 1, Character: &amp;#34;g&amp;#34;, Color: &amp;#34;green&amp;#34;, Name: &amp;#34;Goblin&amp;#34;}, &amp;#34;hitpoints&amp;#34;: ecs.HitPointComponent{Hp: 5, MaxHP: 5}, &amp;#34;movement&amp;#34;: ecs.MovementComponent{}}) We&amp;rsquo;re using the AddComponents() function easily add multiple components at once to our created entities, but other than that, we create these in much the same way as our player. This highlights, I think, how easy it is to compose new entities.
At this point, we should have all of our entities drawing to the screen properly. Lets now tackle movement, before we wrap up. We&amp;rsquo;re going to add a new component (hinted at above) called MovementComponent, and along with that, a new system, SystemMovement. My goal is to make all of our systems as generic as possible, so that we are not handling special cases that are unique to the player (you&amp;rsquo;ll see this our SystemMovement system, as in theory, it will be possible to control any entity in the game; the result of a mind control spell, maybe?).We&amp;rsquo;ll also add a flag component, to indicate if the entity is controllable or not. Lets add our component first:
// Movement Component type MovementComponent struct { } func (m MovementComponent) IsAIComponent() bool { return false } // Controllable Component type ControllableComponent struct { } func (c ControllableComponent) IsAIComponent() bool { return false } Nothing new here, its still not an AI component either. Now, lets code up the accompanying system. This will be very similar to how we&amp;rsquo;re currently handling movement, except we&amp;rsquo;re going to do some checks for components beforehand:
func SystemMovement(entity *GameEntity, dx, dy int, entities []*GameEntity, gameMap *gamemap.Map, messageLog *ui.MessageLog) { // Allow a moveable and controllable entity to move 	if entity.HasComponents([]string{&amp;#34;movement&amp;#34;, &amp;#34;controllable&amp;#34;, &amp;#34;position&amp;#34;}) { // If the current entity is controllable, moveable, and has a position, go ahead and move it 	positionComponent, _ := entity.Components[&amp;#34;position&amp;#34;].(PositionComponent) if !gameMap.IsBlocked(positionComponent.X&#43;dx, positionComponent.Y&#43;dy) { target := GetBlockingEntitiesAtLocation(entities, positionComponent.X&#43;dx, positionComponent.Y&#43;dy) if target != nil { // SystemAttack(entity, target, messageLog) - this is our Attack system; next time! 	} else { positionComponent.X &#43;= dx positionComponent.Y &#43;= dy entity.RemoveComponent(&amp;#34;position&amp;#34;) entity.AddComponent(&amp;#34;position&amp;#34;, positionComponent) } } } else { // Implement an AI component here (later) 	} } First, we&amp;rsquo;re checking for the movement, controllable, and position components. If an entity is missing any of these, we&amp;rsquo;ll pass it off to an AI routine (next post), and let it decide what to do. If the entity is controllable, has movement, and has a position though, we need to handle that. We will have a dx and dy value, which will be passed in from our key handling function, and those will get applied as normal to move the controllable entity. Note, this does not apply just to the player, but any entity that happens to have the controllable component. This means that the player may be able to control multiple entities in a turn.
To use this system, we just need to call it. Back in our main game file, in our main() function:
func main () { ... for { blt.Refresh() key := blt.Read() // Clear each Entity off the screen 	ecs.SystemClear(entities, gameCamera) if key != blt.TK_CLOSE { if gameTurn == PlayerTurn { if player.HasComponents([]string{&amp;#34;movement&amp;#34;, &amp;#34;controllable&amp;#34;, &amp;#34;position&amp;#34;}) { handleInput(key, player) } } } else { break } if gameTurn == MobTurn { var newEntities []*ecs.GameEntity for _, e := range entities { if e != nil { if !e.HasComponent(&amp;#34;player&amp;#34;) { ecs.SystemMovement(e, 0, 0, entities, gameMap, &amp;amp;messageLog) } } } gameTurn = PlayerTurn } renderMap() ecs.SystemRender(entities, gameCamera, gameMap) messageLog.PrintMessages(ViewAreaY, WindowSizeX, WindowSizeY) } blt.Close() } We&amp;rsquo;re now calling our new movement system anywhere an entity may move. In particular, on the players turn, we check to make sure he has all the correct components, and then hand off control to the handleKeys function (which calls SystemMovement, once the movement keys have been resolved). For monsters, we&amp;rsquo;re doing the same, but anticipating they will not be controllable, and thus will hand off control to an AI system (in a later post). We are now using a single unified system for every entity in the game that can move.
And with that, we should have a functional game again (except enemies will not move). The player and all other entities get drawn to the screen, and the player can move around as normal. And the best part, we now have a flexible system for extending our game in the future. This will be a huge asset to us as we continue to add more and more complex features down the road. As usual, you can check out the code for this post in the repo here.
Next time, we&amp;rsquo;re finally going to get to some combat, and give our monsters some proper AI, so that they will seek and out (possibly) destroy the player. Stay tuned, and until then, happy developing!
]]></content:encoded>
    </item>
    <item>
      <title>RLDBAR Sidenote #2: Vim Keys and Diagonal Movement</title>
      <link>https://jeremyceri.se/post/sidenote-2-vim-keys/</link>
      <pubDate>Fri, 28 Jul 2017 04:10:20 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/sidenote-2-vim-keys/</guid>
      <description>In this second sidenote to the main RLDBAR tutorial, we&amp;rsquo;re going to make a very small, but very useful change: diagnonal movement, and allowing users to move via VIM keys. The first, diagonal movement, opens up many more tactical options over just being able to move in the cardinal directions (north, south, east, west), and will give the player more flexibility. Adding in support for VIM key movement (h, j, k, l, y, u, b, n) will give our game a bit more reach to users without full keyboards (not that we&amp;rsquo;ve implemented number pad support yet&amp;hellip; :P ).</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[In this second sidenote to the main RLDBAR tutorial, we&amp;rsquo;re going to make a very small, but very useful change: diagnonal movement, and allowing users to move via VIM keys. The first, diagonal movement, opens up many more tactical options over just being able to move in the cardinal directions (north, south, east, west), and will give the player more flexibility. Adding in support for VIM key movement (h, j, k, l, y, u, b, n) will give our game a bit more reach to users without full keyboards (not that we&amp;rsquo;ve implemented number pad support yet&amp;hellip; :P ). Lets get it done!
As I already mentioned, this is a very small, even trivial, change. Lets just go ahead and look at the code (this is the handleInput() function from our main file):
func handleInput(key int, entity *ecs.GameEntity) { // Handle basic character movement in the four main directions, plus diagonals (and vim keys)  var ( dx, dy int ) switch key { case blt.TK_RIGHT, blt.TK_L: dx, dy = 1, 0 case blt.TK_LEFT, blt.TK_H: dx, dy = -1, 0 case blt.TK_UP, blt.TK_K: dx, dy = 0, -1 case blt.TK_DOWN, blt.TK_J: dx, dy = 0, 1 case blt.TK_Y: dx, dy = -1, -1 case blt.TK_U: dx, dy = 1, -1 case blt.TK_B: dx, dy = -1, 1 case blt.TK_N: dx, dy = 1, 1 } ... } And thats it. All we&amp;rsquo;re doing is allowing the player to use the standard VIM movement keys (l for right, h for left, k for up, and j for down) for cardinal navigation (in addition to the arrow keys). This makes our movement more flexible, and more VIM friendly (sorry emacs fans).
The next addition is the four cases for the y, u, b, and n keys. These will allow for diagonal movement. Y for example, will move our player -1 on the x axis, and -1 on the y axis, which translates to diagonally up and to the left. N, on the other hand, translates to diagonally down and to the right.
Pretty straight forward, but very powerful, especially since any monsters we create in the future will be able to move diagonally. We wouldn&amp;rsquo;t want them to have an unfair advantage, now would we?
That&amp;rsquo;s about all for this sidenote, I don&amp;rsquo;t have a release for this one, as it was such a small change, but you can always check out the latest code for the in progress roguelike on my repo. Hopefully, I&amp;rsquo;ll be back on the main tutorial track here shortly, and until then, happy developing!
]]></content:encoded>
    </item>
    <item>
      <title>RoguelikeDev Builds a Roguelike, Part 6</title>
      <link>https://jeremyceri.se/post/roguelike-dev-week-3-part-2/</link>
      <pubDate>Mon, 24 Jul 2017 04:20:22 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/roguelike-dev-week-3-part-2/</guid>
      <description>Welcome back to my series about building a Roguelike in Go (and following along with RoguelikeDev&amp;rsquo;s dev-along)! Last time, we added a field of vision algorithm to our game, putting the player in the dark, except the immediate area surrounding them. In this installment, we&amp;rsquo;re going to start adding the framework for monsters that inhabit the dark corners of the caverns. In particular, our goal will be to randomly place Game Entities, representing things such as Goblins, Troll, and Orcs, around our generated caverns, make sure they get to take actions, and allow the player to interact with them.</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[Welcome back to my series about building a Roguelike in Go (and following along with RoguelikeDev&amp;rsquo;s dev-along)! Last time, we added a field of vision algorithm to our game, putting the player in the dark, except the immediate area surrounding them. In this installment, we&amp;rsquo;re going to start adding the framework for monsters that inhabit the dark corners of the caverns. In particular, our goal will be to randomly place Game Entities, representing things such as Goblins, Troll, and Orcs, around our generated caverns, make sure they get to take actions, and allow the player to interact with them. We&amp;rsquo;ll be adding proper combat in a later post, but for now, lets add some monsters!
A pertinent question that we should ask, before we dive in, is how are we going to represent the monsters that will inhabit the depths of our caverns? You may recall that we have a struct for just such a thing: GameEntity. Our GameEntity struct is exactly what we need to create monsters. GameEntity&amp;rsquo;s sole purpose is to represent &amp;lsquo;things&amp;rsquo; in the game world, whether that be items, chests, NPCs, monsters, or the player. So far, we&amp;rsquo;ve only used the GameEntity struct to represent our player (and a short lived NPC), but now we&amp;rsquo;re going to start leveraging it much, much more.
We need to do some small additions to our GameEntity struct before we move forward. We&amp;rsquo;re going to add a name property, as well as property that indicates whether this entity blocks movement (in the exact same way that a Tile does):
type GameEntity struct { X int Y int Layer int Char string Color string Name string Blocks bool } Nothing fancy there, just a string and a bool.
Now that we have that additional data attached to our entities, lets put some thought into how we want to go about creating new monster entities, and adding them to our game world. The easiest approach to this, and the one we&amp;rsquo;re going to stick with for the time being, is to just randomly place some created entities around the map. There are a few challenges with this approach however: 1) We don&amp;rsquo;t want to place entities outside the bounds of where the player can go, and 2) we don&amp;rsquo;t want to place entities on top of one another. Lets setup the solution for the second issue first.
What we need is a way to see if there is a blocking entity at a given location. The way this should work is that, whenever we go to place an entity on our map, we will feed the intended coordinates into a function that checks the location of every entity currently placed, and make sure that one of them is not present at the location we are trying to use. This should be pretty easy to do, as we are also going to be keeping a (more or less) global list of entities that are present on the map. A logical place for this code to live in our entity package. This new function doesn&amp;rsquo;t need to be attached to the GameEntity struct, but from an organizational standpoint, it makes sense to put it in the same file:
func GetBlockingEntitiesAtLocation(entities []*GameEntity, destinationX, destinationY int) *GameEntity { // Return any entities that are at the destination location which would block movement 	for _, e := range entities { if e.Blocks &amp;amp;&amp;amp; e.X == destinationX &amp;amp;&amp;amp; e.Y == destinationY { return e } } return nil } We pass in a slice containing every entity currently present on the map, and the intended (x, y) coordinates for our new entity. We then check to see if there is an entity present, and if it blocks. If it does, we simply return that entity, or nil if nothing is present at the desired location.
Alright, we&amp;rsquo;ve now got a way to check valid entity locations, lets set about actually creating and placing a bunch of monster entities on our map!
At this point, I&amp;rsquo;ve decided to refactor my previous code a bit. We&amp;rsquo;re going to be dealing with map related functions (generating and placing monsters based on the type of map), so it makes sense that the monster generation and placement code lives in the gamemap package. Previously, I had one file, gamemap.go, which contained all the map logic. I decided, to keep things tidy, to break the gamemap.go file into three files: gamemap.go, which contains the core, common map logic; arena.go, which contains all code related to arena maps; and cavern.go, which contains all logic specific to caverns. You can look here to see the specifics of how this is now laid out. This is strictly an organizational change, so don&amp;rsquo;t feel obligated to follow my lead, if you don&amp;rsquo;t want to.
Anyways&amp;hellip;
We&amp;rsquo;re going to add a new function that will generate and place monsters in our cavern maps (I&amp;rsquo;m ignoring arenas, since that&amp;rsquo;s more for testing at the moment). Since we&amp;rsquo;re dealing with cavern maps, I&amp;rsquo;ve decided to call my function &amp;lsquo;populateCavern&amp;rsquo;. Lets look at the code, and I&amp;rsquo;ll explain it afterwards:
func populateCavern(mainCave []*Tile) []*entity.GameEntity { // Randomly sprinkle some Orcs, Trolls, and Goblins around the newly created cavern 	var entities []*entity.GameEntity var createdEntity *entity.GameEntity for i := 0; i &amp;lt; 2; i&#43;&#43; { x := 0 y := 0 locationFound := false for j := 0; j &amp;lt;= 50; j&#43;&#43; { // Attempt to find a clear location to create a mob (entity for now) 	pos := rand.Int() % len(mainCave) x = mainCave[pos].X y = mainCave[pos].Y if entity.GetBlockingEntitiesAtLocation(entities, x, y) == nil { locationFound = true break } } if locationFound { chance := rand.Intn(100) if chance &amp;lt;= 25 { // Create a Troll 	createdEntity = &amp;amp;entity.GameEntity{X: x, Y: y, Layer: 1, Char: &amp;#34;T&amp;#34;, Color: &amp;#34;dark green&amp;#34;, Blocks: true, Name: &amp;#34;Troll&amp;#34;} } else if chance &amp;gt; 25 &amp;amp;&amp;amp; chance &amp;lt;= 50 { // Create an Orc 	createdEntity = &amp;amp;entity.GameEntity{X: x, Y: y, Layer: 1, Char: &amp;#34;o&amp;#34;, Color: &amp;#34;darker green&amp;#34;, Blocks: true, Name: &amp;#34;Orc&amp;#34;} } else { // Create a Goblin 	createdEntity = &amp;amp;entity.GameEntity{X: x, Y: y, Layer: 1, Char: &amp;#34;g&amp;#34;, Color: &amp;#34;green&amp;#34;, Blocks: true, Name: &amp;#34;Goblin&amp;#34;} } entities = append(entities, createdEntity) } else { // No location was found after 50 tries, which means the map is quite full. Stop here and return. 	break } } return entities } populateCavern() takes a list of Tiles called mainCave. You may remember from the post on map generation that our cavern generation algorithm keeps track of the main cave area used during the final steps of the process. We&amp;rsquo;re going to pass that slice into our populateCavern() function, as it contains a list of all clear, non-wall Tiles in the playable area, which is exactly what we need.
We start off by creating a for loop. This outer loop will determine how many monsters we generate. I&amp;rsquo;ve set mine to 2, but you can tweak that value to your liking. Next, we step into an inner loop, that runs no more than 50 times. This loop is going to attempt to find a valid, clear location for our new (yet to be created) monster. The reason for this loop is simple: we are going to randomly generate coordinates within our cavern, and then check if it is a clear (no blocking entity present) location. If it is not, we will iterate, and try again, with a new set of random coordinates. We will keep looping and looking until a valid location is found. If the loop runs for more than 50 iterations, its pretty safe to assume that there are no valid locations left, and the loop should break. This will prevent our game from endlessly looking for a valid location, when one may not even exist.
The location checker loop is pretty straight forward. We grab a random position within the mainCave, and get the (X, Y) values from the Tile at that location. We then use our new GetBlockingEntitiesAtLocation() function, passing in the randomly generated (x, y) coordinates. If that function returns nil, we have found a valid location, and we set the locationFound variable to true, and break out of the loop. If no valid location is found, we try again. If all 50 iterations are used up, the loop will end, with locationFound still having a value of false.
Next, if a location was in fact found, we generate a random number between 1 and 100. This will give us a 25% chance of creating a Troll, a 25% chance of creating an Orc, and a 50% chance of creating a Goblin. We then create the appropriate entity, using our new name and blocks properties.
Finally, we append the newly created entity onto the local entities slice, which will be returned.
We&amp;rsquo;ve now got some entities, in valid locations, for our map. Lets quickly look at the code in GenerateCavern() that calls this new function:
func (m *Map) GenerateCavern() (int, int, []*entity.GameEntity) { ... // Populate the cavern with some nasty critters 	entities := populateCavern(mainCave) // Finally, choose a starting position for the player within the newly created cave 	pos := rand.Int() % len(mainCave) return mainCave[pos].X, mainCave[pos].Y, entities } You can see I&amp;rsquo;ve changed the signature a bit, as GenerateCavern() now returns a slice of GameEntity, alongside the valid coordinates for the player. Beyond that, we simply call the populateCavern() function, and assign the slice of returned entities to the &amp;lsquo;entities&amp;rsquo; variable, and then return that alongside the players (x, y) position.
Finally, lets get those entities drawn to the screen! Back in our main file, in our init() function, we&amp;rsquo;re going to add a small update:
func init() { ... playerX, playerY, mapEntities := gameMap.GenerateCavern() player.X = playerX player.Y = playerY entities = append(entities, mapEntities...) ... } We&amp;rsquo;re now grabbing the returned GameEntity slice from our GenerateCavern() function. Earlier, we created a slice called entities (of which our player is a part) that was intended to contain every entity currently on the map. Here, we are simply appending the mapEntities slice to the (sort of) global entities slice. This will ensure that our entities from our map generation get drawn correctly, along side our player, each turn!
(You may notice that there is console output on my game. This is the topic of an upcoming SideNote, so stay tuned if that interests you.)
We&amp;rsquo;ve successfully generated, placed, and drawn several (not yet) threatening monsters onto our game map. But&amp;hellip;they don&amp;rsquo;t really do much, and if the player attempts to interact with them, you&amp;rsquo;ll find you can walk right through them as if they&amp;rsquo;re not even there. These are some cut-rate monsters&amp;hellip; Lets fix that!
As it stands right now, the player takes an action (currently only moving is implemented), and then is allowed to take another action, and another, and another, ad nauseum. We need a way to let the monsters take a turn, after the player has done something. Essentially, we are going to consider one action by the player to be his turn. So, the player moving north one Tile, or the player drinking a potion, or resting, these are all actions that would end the players turn. Once the player has acted, we want to let the monsters on the map do something as well. We&amp;rsquo;re going to need some way of keeping track of the current turn, or game state.
Lets do that first. We&amp;rsquo;ll create a couple of new constants, one called PlayerTurn, and one called MobTurn. What we&amp;rsquo;re aiming for is basically an enum that we can reference to check or set the current state of the game, the players turn, or the monsters turn. Since Go doesn&amp;rsquo;t have direct support for an enum type, I&amp;rsquo;m going to use a language feature called &amp;lsquo;iota&amp;rsquo;. The iota keyword will auto-increment its value each time we call it, meaning that if we call it three times in sequence, each call will have a value of (1 &#43; last_iota_value). This is super handy for creating enum like variable sets:
const ( WindowSizeX = 100 WindowSizeY = 35 MapWidth = 100 MapHeight = 35 Title = &amp;#34;BearRogue&amp;#34; Font = &amp;#34;fonts/UbuntuMono.ttf&amp;#34; FontSize = 24 PlayerTurn = iota MobTurn = iota ) Now, I&amp;rsquo;m going to set a new variable called gameTurn:
var ( player *entity.GameEntity entities []*entity.GameEntity gameMap *gamemap.Map gameCamera *camera.GameCamera fieldOfView *fov.FieldOfVision gameTurn int ) Finally, in our init() function, we&amp;rsquo;re going to set the gameTurn to the player:
func init() { ... // Set the current turn to the player, so they may act first 	gameTurn = PlayerTurn ... } The gameTurn variable will regularly get flipped from state to state. Once the player takes an action, it flips to MobTurn, and the monsters all get to take one action. Once they are done, it will flip back to PlayerTurn, etc. This sets up a nice turn by turn flow for the game, with every entity getting one action per turn.
Now, in our main game loop, we need to implement that logic. Turns out, its pretty simple:
func main() { ... if key != blt.TK_CLOSE { if gameTurn == PlayerTurn { handleInput(key, player) } } else { break } if gameTurn == MobTurn { for _, e := range entities { if e != player { if gameMap.Tiles[e.X][e.Y].Visible { // Check to ensure that the entity is visible before allowing it to message the player 	// This will change soon, as entities will act whether the player can see them or not. 	fmt.Printf(&amp;#34;The %s waits patiently...&amp;#34;, e.Name) } } } gameTurn = PlayerTurn } ... } When we check for player input, we also check to see if it is in fact the players turn. If it is, we allow the input to be processed. If not, we skip over the action and continue. If it is the players turn, we call handleInput as normal, but there&amp;rsquo;s one small change in there:
func handleInput(key int, player *entity.GameEntity) { ... // Check to ensure that the tile the player is trying to move in to is a valid move (not blocked) 	if !gameMap.IsBlocked(player.X &#43; dx, player.Y &#43; dy) { target := entity.GetBlockingEntitiesAtLocation(entities, player.X &#43; dx, player.Y &#43; dy) if target != nil { fmt.Printf(&amp;#34;You harmlessly bump into the %s&amp;#34;, target.Name) } else { player.Move(dx, dy) } } // Switch the game turn to the Mobs turn 	gameTurn = MobTurn } After we check if the desired location is blocked, we also check to see if there is a blocking entity present. If there is, we stop the movement, similar to how we stop movement into a wall, and print a message letting the player know that they have bumped into something nasty. Finally, we switch the game turn to the monsters.
Back in the main game loop, we check if its the monsters turn. If it is, we loop (naively right now, we&amp;rsquo;ll make this better later) through every entity on the map, being sure to skip the player, and let them take an action. Right now that action consists of printing out that its waiting patiently, but later this will be things like moving, attacking, etc.
And that&amp;rsquo;s it! If you fire up the game now, you should be able to find some monsters, which should act in reaction to your movement, and allow you to harmlessly bump into them.
This has laid the groundwork for our upcoming combat system. We&amp;rsquo;ve allowed the player to interact with other entities, a theme we&amp;rsquo;re going to continue to develop, as its one of the core mechanics of the game. We also set up a system to randomly fill our caves and dungeons with all sorts of nasty creatures, just waiting to hassle the player.
As usual, if you want to see the code for this post, you can find it here. Next time, we&amp;rsquo;ll be fleshing out the combat system, and adding some nice GUI components. Until then, happy developing!
This way to Part 7: ECS Refactor
]]></content:encoded>
    </item>
    <item>
      <title>RoguelikeDev Builds a Roguelike, Part 5</title>
      <link>https://jeremyceri.se/post/roguelike-dev-week-3-part-1/</link>
      <pubDate>Fri, 14 Jul 2017 04:30:50 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/roguelike-dev-week-3-part-1/</guid>
      <description>Welcome to part 5 of RoguelikeDev builds a Roguelike! In this weeks installment, we&amp;rsquo;re going to be talking about field of vision (fov for short), and how we can apply that to our game in progress. Field of vision is how far the player can see. If something is beyond the field of vision of the player, it will not be visible. This adds a nice exploration element to our game, as the game map starts completely unexplored.</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[Welcome to part 5 of RoguelikeDev builds a Roguelike! In this weeks installment, we&amp;rsquo;re going to be talking about field of vision (fov for short), and how we can apply that to our game in progress. Field of vision is how far the player can see. If something is beyond the field of vision of the player, it will not be visible. This adds a nice exploration element to our game, as the game map starts completely unexplored. It also will help add a sense of danger, once we start adding content, as the player will never know whats around the next corner.
Lets start off by discussing what field of vision (or view), actually is. Fov is literally the distance that the player can see on our map. If we say that the player has a fov of 6, that would mean, for the purposes of our game, that the player is able to see 6 spaces in every direction, essentially forming a circle of vision around him. As the player moves around the map, the fov moves with him, so that the player can always see Tiles that are 6 spaces away or closer. Obviously, we can tweak the distance the player can see, but for now, I&amp;rsquo;m going to leave it at a default value of 6.
As the player moves around the map, we also want to keep track of which Tiles have already been explored (&amp;lsquo;seen&amp;rsquo; by the player, or within the players fov). The purpose of this is that we want to show the player Tiles that have already been visited, but grayed out. This will create the effect of the player knowing where he has already been, while maintaining the mystery of what could be lurking outside of the fov. You can think of this grayed out area as a fog of war type system. It will help the player by showing the map that has been explored, while also hiding any Entities that may be lurking in already explored areas.
The approach I chose for fov in my game is a technique called ray casting. Ray casting is just that: you cast out a ray for each degree of a circle (360, or fewer, if you want less accuracy), and see what it intersects. If the ray intersects a floor tile, it should keep going (remember, floor tiles do not block movement or vision). If the ray intersects with a Tile that blocks sight (blocks_sight = true), then it should stop, as the player will not be able to see beyond that. Finally, if a ray would intersect the edge of the map, it should also stop.
So, we will cast 360 rays around the player. For each ray, we will add the players current X position to sin(i degrees) and the players current Y position to cos(i degrees), x times, where x is the radius of the players fov (in this case 6). Each step, we check for collision with a Tile that blocks sight. If one is not encountered, we will mark the Tile as explored and visible, and move on, until either the ray passes beyond the players fov, or a wall/other blocking Tile is encountered.
Once we are done deciding what is in the players fov, we will clear the map, and redraw everything, with Tiles in the fov being white, and explored Tiles being gray. Everything else will not get drawn, since it has not yet been explored.
Alright, that&amp;rsquo;s enough talking about it, lets actually code it up!
We&amp;rsquo;re going to start (as usual), by creating a new package, called fov. In that package, we&amp;rsquo;re going to define a struct, called FieldOfVision:
type FieldOfVision struct { sinTable map[int]float64 cosTable map[int]float64 torchRadius int } The sinTable and cosTable maps will contain our pre-calculated values for sin and cos, which we&amp;rsquo;ll see how to initialize in a minute. TorchRadius will be the radius (distance) that the player can see around him. We&amp;rsquo;re going to add a setter for torchRadius, so future gameplay elements can modify how far the player can see (like a &#43;10 Rod of Blazing Sunlight, for example). Now that we have our struct, lets attach the aforementioned setter method for torchRadius, and an initialize function to it:
func (f *FieldOfVision) Initialize() { f.cosTable = make(map[int]float64) f.sinTable = make(map[int]float64) for i := 0; i &amp;lt; 360; i&#43;&#43; { ax := math.Sin(float64(i) / (float64(180) / math.Pi)) ay := math.Cos(float64(i) / (float64(180) / math.Pi)) f.sinTable[i] = ax f.cosTable[i] = ay } } func (f *FieldOfVision) SetTorchRadius(radius int) { if radius &amp;gt; 1 { f.torchRadius = radius } } Our Initialize() function serves to set up the pre-calculated values for our sin and cos maps, as discussed earlier. We simply calculate one value for each degree of a circle, to be sin(i / 180 / PI) and cos(i / 180 / PI). This will give us an easy way to cast our rays out from the player in increments of 1 degree later on.
The TorchRadius() function is just a simple setter for torchRadius, but it never lets the value go below 1. We don&amp;rsquo;t the player to be left completely in the dark. Yet, anyways.
Before we move on, we need to add a couple of properties to our Tile struct:
type Tile struct { Blocked bool Blocks_sight bool Visited bool Explored bool Visible bool X int Y int } Pretty simple, we just added a Explored and Visible bool, which should be pretty self explanatory. If not, we&amp;rsquo;ll be jumping into their uses momentarily.
Alright, now that we have initialization out of the way, lets get into the meat of the fov code, the actual ray casting. This function will not only handle casting of rays, it will also be responsible for marking a Tile as explored or visible. I&amp;rsquo;m gonna dump the whole function here, and then explain it step by step afterwards.
func (f *FieldOfVision) RayCast(playerX, playerY int, gameMap *gamemap.Map) { // Cast out rays each degree in a 360 circle from the player. If a ray passes over a floor (does not block sight) 	// tile, keep going, up to the maximum torch radius (view radius) of the player. If the ray intersects a wall 	// (blocks sight), stop, as the player will not be able to see past that. Every visible tile will get the Visible 	// and Explored properties set to true.  for i := 0; i &amp;lt; 360; i &#43;&#43; { ax := f.sinTable[i] ay := f.cosTable[i] x := float64(playerX) y := float64(playerY) // Mark the players current position as explored 	gameMap.Tiles[playerX][playerY].Explored = true for j := 0; j &amp;lt; f.torchRadius; j&#43;&#43; { x -= ax y -= ay roundedX := int(Round(x)) roundedY := int(Round(y)) if x &amp;lt; 0 || x &amp;gt; float64(gameMap.Width - 1) || y &amp;lt; 0 || y &amp;gt; float64(gameMap.Height - 1) { // If the ray is cast outside of the map, stop 	break } gameMap.Tiles[roundedX][roundedY].Explored = true gameMap.Tiles[roundedX][roundedY].Visible = true if gameMap.Tiles[roundedX][roudnedY].Blocks_sight == true { // The ray hit a wall, go no further 	break } } } } func Round(f float64) float64 { return math.Floor(f &#43; .5) } To start with, our RayCast() function takes three arguments, the current player X and Y position, and a pointer to the current GameMap. The players X and Y are the origin for our ray casting, and we&amp;rsquo;ll use the GameMap&amp;rsquo;s Tiles property to keep track of which tiles are visible and explored (thus why its a pointer).
We start things off by setting up a loop that will iterate 360 times. This can be tweaked if we want less accuracy, by incrementing i by &#43;2, or &#43;3, etc. This will be more efficient, but the fov will not be as accurate. Something to play with later. We then grab the value for this degree from our pre-calculated sin and cos tables, and then convert the players X and Y into float64, as that&amp;rsquo;s the type of our sin and cos values. Lastly, we set the Tile that the player currently occupies as explored.
Next, we iterate x times, where x is the torchRadius (in our case, 6). This is where we will actually begin casting the rays from the player (origin). We subtract the sin value from player.X and the cos value from player.Y. This will give us an approximation of one tile away, in the direction of whatever degree we are currently calculating. We then check to make sure that Tile is not outside of the map (if it is, quit early, as the edge of the map technically blocks sight). Then, we mark the Tile as both explored and visible. If it is a wall, it will be illuminated, but nothing beyond it will be visible. If its floor, it will be illuminated, and the Tiles beyond will be visible as well. Finally, we check to see if the Tile blocks sight. If it does, we&amp;rsquo;ll break out of the loop, as nothing beyond the wall Tile is visible.
[Update: 7/17/17] As a note, I was originally just casting my float64s back to ints, which seemed to generally work alright, but as user VedVid on Reddit pointed out, Go will just remove the precision when casting this way, so 5.999999999 becomes 5. Obviously, this throws out a lot of accuracy in how we are getting the tiles that are visible. So, I added a very simple little round function, that will at least give us the correct rounded number when we cast back to an int. Round(5.9999999) will return 6, whereas Round(5.23457) will return 5, as we would expect. This should result in much more accurate fov caclulations. Thanks, VedVid!
That&amp;rsquo;s it, we&amp;rsquo;re basically just checking 360 degrees around the player, and marking visible tiles as visible and explored. Tiles that are neither visible nor explored will not be displayed to the player.
Cool, so now lets actually use our new FieldOfView struct. Back in our main file, we&amp;rsquo;ll need to initialize a new FieldOfView object:
var ( ... fieldOfVision *fov.FieldOfVision ) func init() { ... fieldOfVision = &amp;amp;fov.FieldOfVision{} fieldOfVision.Initialize() fieldOfVision.SetTorchRadius(6) } Once we have our fieldOfVision var initialized and the torchRadius set, we&amp;rsquo;re ready to start using it. We&amp;rsquo;re going to be altering our renderMap() function:
func renderMap() { // Render the game map. If a tile is blocked and blocks sight, draw a &amp;#39;#&amp;#39;, if it is not blocked, and does not block 	// sight, draw a &amp;#39;.&amp;#39;  // First, set the entire map to not visible. We&amp;#39;ll decide what is visible based on the torch radius. 	// In the process, clear every Tile on the map as well 	for x := 0; x &amp;lt; gameMap.Width; x&#43;&#43; { for y := 0; y &amp;lt; gameMap.Height; y&#43;&#43; { gameMap.Tiles[x][y].Visible = false blt.Print(x, y, &amp;#34; &amp;#34;) } } // Next figure out what is visible to the player, and what is not. 	fieldOfView.RayCast(player.X, player.Y, gameMap) // Now draw each tile that should appear on the screen, if its visible, or explored 	for x := 0; x &amp;lt; gameCamera.Width; x&#43;&#43; { for y := 0; y &amp;lt; gameCamera.Height; y&#43;&#43; { mapX, mapY := gameCamera.X &#43; x, gameCamera.Y &#43; y if gameMap.Tiles[mapX][mapY].Visible { if gameMap.Tiles[mapX][mapY].IsWall() { blt.Color(blt.ColorFromName(&amp;#34;white&amp;#34;)) blt.Print(x, y, &amp;#34;#&amp;#34;) } else { blt.Color(blt.ColorFromName(&amp;#34;white&amp;#34;)) blt.Print(x, y, &amp;#34;.&amp;#34;) } } else if gameMap.Tiles[mapX][mapY].Explored { if gameMap.Tiles[mapX][mapY].IsWall() { blt.Color(blt.ColorFromName(&amp;#34;gray&amp;#34;)) blt.Print(x, y, &amp;#34;#&amp;#34;) } else { blt.Color(blt.ColorFromName(&amp;#34;gray&amp;#34;)) blt.Print(x, y, &amp;#34;.&amp;#34;) } } } } } The very first thing we do, is clear every single Tile off the visible map. We do this by setting its visible property to false, and replacing it with a &#39; &#39; character. This is necessary, as every iteration through the game loop, we will need to recalculate our fov (this is not entirely true, and a good spot for some future improvement; only recalculate the fov when the player has moved, for example. Our current approach is a bit naive). Recalculating the fov will set a new batch of Tiles as visible, and if we didn&amp;rsquo;t clear the old ones, we would have a line of visible Tiles behind the character as movement occurred, and also get some strange artifacts when the map is drawn.
After we clear the map, we actually recalculate the fov. We do this simply by calling our RayCast() function, which will not only cast our rays, but also mark every tile that is visible and explored for us.
From there, its just a matter of drawing out all the Tiles on the map that are either explored, or visible. As I stated earlier, visible Tiles will be &amp;ldquo;illuminated&amp;rdquo; by being drawn white, where as Tiles that have been explored, but are not currently in the players fov (not visible), will be grayed out, and drawn gray. This gives a nice effect of the player knowing whats out where he has explored, but not being able to see it anymore. You&amp;rsquo;ll notice we have no case for if a Tile is not explored, nor visible. These tiles simply do not get drawn.
Lets fire up the game! You should see something looks a bit like this:
And, after you move around a bit and explore:
Very nice! Its pretty clear where you&amp;rsquo;ve been, and what you can currently see. And its also pretty clear what hasn&amp;rsquo;t been explored yet!
One last thing we need to take care of, in preparation for the next part (adding monsters), is making sure that any entities other than the player are not visible, unless they are within the players field of vision (like our hapless, red NPC in the far left corner of the map). To do this, we simply need to check if the Tile they occupy is visible. If its not, don&amp;rsquo;t draw it:
func renderEntities() { // Draw every Entity present in the game. This gets called on each iteration of the game loop. 	for _, e := range entities { cameraX, cameraY := gameCamera.ToCameraCoordinates(e.X, e.Y) if gameMap.Tiles[e.X][e.Y].Visible { e.Draw(cameraX, cameraY) } } } Easy. Now any entities outside the line of sight will not be drawn. The player will have to hunt them down to see them (or wait until they hunt him down&amp;hellip;).
And that wraps up Field of Vision. Our game is getting closer and closer to actually being fun, at this point. We&amp;rsquo;ve added some element of exploration by making sure the player can only see a small area around itself, and made sure that already explored Tiles are duly documented as the player delves ever deeper. If you would like to see the source for this post, you can view it on my repo under the v0.0.6 release.
Join me next time, when we will start adding monsters and such to the dungeon, and outline the framework for combat! Until then, happy developing.
This way to part 6
]]></content:encoded>
    </item>
    <item>
      <title>RoguelikeDev Builds a Roguelike, Part 4</title>
      <link>https://jeremyceri.se/post/roguelike-dev-week-2/</link>
      <pubDate>Tue, 11 Jul 2017 19:41:06 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/roguelike-dev-week-2/</guid>
      <description>Welcome to Part 4 of RoguelikeDev builds a Roguelike! This week, we&amp;rsquo;re going to be fleshing out the map that the player will be playing the game on. If you recall, last time, we created an &amp;lsquo;arena&amp;rsquo; sort of map, with a large open space in the middle, surrounded by walls along the outside edges. Not very exciting, but it was something for the player to mover around in. This week, we&amp;rsquo;re going to procedurally generate some (hopefully) realistic looking caverns that the player can explore.</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[Welcome to Part 4 of RoguelikeDev builds a Roguelike! This week, we&amp;rsquo;re going to be fleshing out the map that the player will be playing the game on. If you recall, last time, we created an &amp;lsquo;arena&amp;rsquo; sort of map, with a large open space in the middle, surrounded by walls along the outside edges. Not very exciting, but it was something for the player to mover around in. This week, we&amp;rsquo;re going to procedurally generate some (hopefully) realistic looking caverns that the player can explore. Certainly more exciting than a big empty room!
This week is all about making an interesting and dynamic map that the player can explore. One of the core tenants of Roguelikes is procedurally generated content, and one area where that is more noticeable is the game map. Every time the player plays our game, it would be awesome if their experience was different. We could certainly hardcode up some maps, and to be sure, there is value in that. But the real fun lies in random levels each and every time the game is played. Keeping true to this, we are going to code up a map generator that will be used whenever we need a new level of our dungeons (you can also extrapolate this concept out to any other map representation, overworld, buildings, etc). I&amp;rsquo;ve decided that, rather than use the standard dungeon generator that the official tutorial uses, we&amp;rsquo;re going to use a cellular automata algorithm to generate some nice looking caverns. I&amp;rsquo;ll probably do the standard dungeon generator as a sidenote in the future.
First things first, before we dive into the meat of things, there are some convenience changes we&amp;rsquo;ll want to make, to make our cartographical lives easier. First, I&amp;rsquo;m going to add an (x, y) coordinate set to our Tile struct, and then I&amp;rsquo;m going to add a couple methods that we will leverage quite a bit later down the line:
type Tile struct { Blocked bool Blocks_sight bool Visited bool X int Y int } func (t *Tile) isWall() bool { if t.Blocks_sight &amp;amp;&amp;amp; t.Blocked { return true } else { return false } } func (t *Tile) is Visited() bool { return t.Visited } Aside from adding an (x, y) set to the Tile, I&amp;rsquo;ve also added a Visited property. This will come in handy later when we need to check if we have already dealt with a Tile during map generation. The two convenience methods should be pretty self explanatory in their uses.
Alright, with that out of the way, lets do a quick refactor of some of our GameMap code:
func (m *Map) InitializeMap() { // Initialize a two dimensional array that will represent the current game map (of dimensions Width x Height) 	m.Tiles = make([][]*Tile, m.Width) for i := range m.Tiles { m.Tiles[i] = make([]*Tile, m.Height) } // Set a seed for procedural generation 	rand.Seed( time.Now().UTC().UnixNano()) } func (m *Map) GenerateArena() { // Generates a large, empty room, with walls ringing the outside edges 	for x := 0; x &amp;lt; m.Width; x&#43;&#43; { for y := 0; y &amp;lt; m.Height; y&#43;&#43; { if x == 0 || x == m.Width- 1 || y == 0 || y == m.Height- 1 { m.Tiles[x][y] = &amp;amp;Tile{true, true, false, x, y} } else { m.Tiles[x][y] = &amp;amp;Tile{false, false, false, x, y} } } } } As you can see, I broke out the actual map generation code from the initialize logic. Initialize now just creates an empty 2D array of Tiles (though none of the Tiles have been initialized yet, or even created). It also sets a seed for our randomization. More on that later.
Next, I broke our old map generation code into a new method, called GenerateArena(). This can be called on an initialized GameMap, and will create our familiar large room surrounded by walls. I&amp;rsquo;m keeping this code around in case we want to create a map like this in the future.
Alright, with the little stuff out of the way, we&amp;rsquo;ve paved the path forward to creating a new map generator. I&amp;rsquo;m going to create a new function, attached to the Map struct, called GenerateCavern (public, as we&amp;rsquo;ll want to call it outside of our map package):
func (m *Map) GenerateCavern() (int, int) {} The two ints that get returned will be a valid starting location for the player, so we can be sure it spawns in a valid location.
We&amp;rsquo;re going to be using whats known as a cellular automata to generate our cave. Cellular automata are most famous from Conways game of Life. I&amp;rsquo;m not going to get into that here, so Google it if you&amp;rsquo;re curious. A cellular automata is essentially a way of representing &amp;ldquo;cells&amp;rdquo; or in our case, Tiles in the map. We will start by generating a random assortment of wall and floor Tiles. Then, we will check each Tile, and see if it should stay in its current state, or transition to the other state. In a traditional cellular automata, this would be called the cell living or dying, but we&amp;rsquo;re going to frame as the Tile being a floor or a wall. We&amp;rsquo;ll set our rules for each Tiles state such that if a wall tile is all by itself (no neighbors that are walls), perhaps it should not be a wall, and if a Tile is surrounded by walls, perhaps it too, should be a wall. This probably sounds a little esoteric, so lets just jump in, and I&amp;rsquo;ll explain as we go (with pretty pictures!).
The first thing we need to do is fill up our empty 2D GameMap with a random assortment of Tiles:
// Step 1: Fill the map space with a random assortment of walls and floors. This uses a roughly 40/60 ratio in favor // of floors, as I&amp;#39;ve found that to produce the nicest results. for x := 0; x &amp;lt; m.Width; x&#43;&#43; { for y := 0; y &amp;lt; m.Height; y&#43;&#43; { state := rand.Intn(100) if state &amp;lt; 50 { m.Tiles[x][y] = &amp;amp;Tile{true, true, false, x, y} } else { m.Tiles[x][y] = &amp;amp;Tile{false, false, false, x, y} } } } All this does, is loop over every element of the GameMap array, generate a random number between 0 and 100, and then give a 50% chance of creating a wall or floor Tile. The 50% is a very tweak-able percentage here, and I encourage you to play with it and see how it changes the overall outcome. I generally find that about 40% works best. Running our GenerateCavern() function should yield something like this:
Again, tweak the percentage and see the changes. It will have a larger impact later, but for now, with a 50% chance, it covers roughly half the map with walls, and half with floor. This random looking mess is going to be the basis for our cavern.
Next up, we&amp;rsquo;re going to go through each Tile we created in the previous step, and see if it should be a wall or a floor, based a couple of very simple rules. First, if 4 or more of the Tiles immediate neighbors are walls, or two or less neighbors up to 2 tiles away are walls, then that Tile becomes (or stays) a wall. If neither of those are true, the tile will become (or stay) a floor. Basically, going back to the cell analogy, if a cell is dead (floor), check to see if it has enough alive (wall) neighbors to be become alive again, and if a cell is alive (wall), check to ensure it has enough alive neighbors to remain alive.
// Step 2: Decide what should remain as walls. If four or more of a tiles immediate (within 1 space) neighbors are // walls, then make that tile a wall. If 2 or less of the tiles next closest (2 spaces away) neighbors are walls, // then make that tile a wall. Any other scenario, and the tile will become (or stay) a floor tile. // Make several passes on this to help smooth out the walls of the cave. for i := 0; i &amp;lt; 5; i&#43;&#43; { for x := 0; x &amp;lt; m.Width; x&#43;&#43; { for y := 0; y &amp;lt; m.Height - 1; y&#43;&#43; { wallOneAway := m.countWallsNStepsAway(1, x, y) wallTwoAway := m.countWallsNStepsAway(2, x, y) if wallOneAway &amp;gt;= 5 || wallTwoAway &amp;lt;= 2 { m.Tiles[x][y].Blocked = true m.Tiles[x][y].Blocks_sight = true } else { m.Tiles[x][y].Blocked = false m.Tiles[x][y].Blocks_sight = false } } } } Lets explain whats going on here. First up, we&amp;rsquo;re going to make several passes over this code (5 to be precise). This will ensure that each time through, we &amp;ldquo;smooth&amp;rdquo; out the newly forming cavern a little bit more. This is also what will allow our cave formations to take shape. Any openings that are present after the first pass will be made more prominent in subsequent passes, as the algorithm tries to maintain groups of like Tiles.
Next, we set up a loop over every Tile in the GameMap, and call a new function, countWallsNStepsAway(). That function, which hopefully should be self explanatory from the name, looks like this:
func (m *Map) countWallsNStepsAway(n int, x int, y int) int { // Return the number of wall tiles that are within n spaces of the given tile 	wallCount := 0 for r := -n; r &amp;lt;= n; r&#43;&#43; { for c := -n; c &amp;lt;= n; c&#43;&#43; { if x &#43; r &amp;gt;= m.Width || x &#43; r &amp;lt;= 0 || y &#43; c &amp;gt;= m.Height || y &#43; c &amp;lt;= 0 { // Check if the current coordinates would be off the map. Off map coordinates count as a wall. 	wallCount &#43;&#43; } else if m.Tiles[x &#43; r][y &#43; c].Blocked &amp;amp;&amp;amp; m.Tiles[x &#43; r][y &#43; c].Blocks_sight { wallCount &#43;&#43; } } } return wallCount } This function simply returns how many neighbors, n steps away from the provided Tile, are walls. We call that function twice, one for immediate (1 step away) neighbors, and once for neighbors two steps away. We then compare those returned values to the rules we laid out above. If it meets the criteria for neighbor walls, it becomes a wall, otherwise, we make it a floor. After one pass, our caverns look like this:
And, after five passes, it looks like this:
You can see how our algorithm has broken out multiple separate caverns, and has &amp;ldquo;smoothed&amp;rdquo; them out, getting rid of jagged edges and odd outcroppings that don&amp;rsquo;t fit in their surroundings. Its actually starting to look like a proper set of caverns!
Next, we&amp;rsquo;ll do a few more passes, but this time only looking for bits of wall that are by themselves, or extremely isolated among floor tiles (this will get rid of the walls that are standing out in the middle of the caverns by themselves):
// Step 3: Make a few more passes, smoothing further, and removing any small or single tile, unattached walls. for i := 0; i &amp;lt; 5; i&#43;&#43; { for x := 0; x &amp;lt; m.Width; x&#43;&#43; { for y := 0; y &amp;lt; m.Height - 1; y&#43;&#43; { wallOneAway := m.countWallsNStepsAway(1, x, y) if wallOneAway &amp;gt;= 5 { m.Tiles[x][y].Blocked = true m.Tiles[x][y].Blocks_sight = true } else { m.Tiles[x][y].Blocked = false m.Tiles[x][y].Blocks_sight = false } } } } This pass is pretty simple, nothing new of note, aside from the slightly different wall rule. After five more passes of this, our cave now looks like this:
We&amp;rsquo;ve now got some nice, smooth, artifact free caverns. The bottom edge of the screen looks a little ragged, but we&amp;rsquo;ll clean that up in a minute. The next thing we&amp;rsquo;re going to do is seal up the edges of the map, in case any of our caverns has an opening off the edge of the map. We don&amp;rsquo;t want the player to be able to wander outside our designated map area:
// Step 4: Seal up the edges of the map, so the player, and the following flood fill passes, cannot go beyond the // intended game area for x := 0; x &amp;lt; m.Width ; x&#43;&#43; { for y := 0; y &amp;lt; m.Height; y&#43;&#43; { if x == 0 || x == m.Width - 1 || y == 0 || y == m.Height - 1 { m.Tiles[x][y].Blocked = true m.Tiles[x][y].Blocks_sight = true } } } This is straight-forward, we just go around the edges, and make every edge Tile a wall.
At this point, we&amp;rsquo;ve got a bunch of small to large caverns, all nicely shaped, and very natural looking (I think so, at least :). However, the astute may have noticed that if the player were to spawn in one cavern, they would have no way of reaching any of the others (no digging in my roguelikes, not fond of the mechanic). So, how do we solve that? Well, the best way is to ensure there is only one main cavern. We could tunnel between each cavern, and run a few more passes of smoothing, but I actually like the idea of choosing the largest continuous cavern, and filling in the rest. That way, we ensure the player can reach every reachable part of the cavern they land in. The approach towards doing this also uses a neat algorithm called a flood fill, which we&amp;rsquo;ll go over next.
// Step 5: Flood fill. This will find each individual cavern in the cave system, and add them to a list. It will // then find the largest one, and will make that as the main play area. The smaller caverns will be filled in. // In the future, it might make sense to tunnel between caverns, and apply a few more smoothing passes, to make // larger, more realistic caverns.  var cavern []*Tile var totalCavernArea []*Tile var caverns [][]*Tile var tile *Tile var node *Tile for x := 0; x &amp;lt; m.Width - 1; x&#43;&#43; { for y := 0; y &amp;lt; m.Height - 1; y&#43;&#43; { tile = m.Tiles[x][y] // If the current tile is a wall, or has already been visited, ignore it and move on 	if !tile.isVisited() &amp;amp;&amp;amp; !tile.isWall() { // This is a non-wall, unvisited tile 	cavern = append(cavern, m.Tiles[x][y]) for len(cavern) &amp;gt; 0 { // While the current node tile has valid neighbors, keep looking for more valid neighbors off of 	// each one 	node = cavern[len(cavern)-1] cavern = cavern[:len(cavern)-1] if !node.isVisited() &amp;amp;&amp;amp; !node.isWall() { // Mark the node as visited, and add it to the cavern area for this cavern 	node.Visited = true totalCavernArea = append(totalCavernArea, node) // Add the tile to the west, if valid 	if node.X - 1 &amp;gt; 0 &amp;amp;&amp;amp; !m.Tiles[node.X -1][node.Y].isWall() { cavern = append(cavern, m.Tiles[node.X -1][node.Y]) } // Add the tile to east, if valid 	if node.X &#43; 1 &amp;lt; m.Width &amp;amp;&amp;amp; !m.Tiles[node.X &#43; 1][node.Y].isWall() { cavern = append(cavern, m.Tiles[node.X &#43; 1][node.Y]) } // Add the tile to north, if valid 	if node.Y - 1 &amp;gt; 0 &amp;amp;&amp;amp; !m.Tiles[node.X][node.Y - 1].isWall() { cavern = append(cavern, m.Tiles[node.X][node.Y - 1]) } // Add the tile to south, if valid 	if node.Y &#43; 1 &amp;lt; m.Height &amp;amp;&amp;amp; !m.Tiles[node.X][node.Y &#43; 1].isWall() { cavern = append(cavern, m.Tiles[node.X][node.Y &#43; 1]) } } } // All non-wall tiles have been found for the current cavern, add it to the list, and start looking for 	// the next one 	caverns = append(caverns, totalCavernArea) totalCavernArea = nil } else { tile.Visited = true } } } Whoa, there&amp;rsquo;s a lot going on there. Lets step through. First off, a flood fill algorithm is literally what it sounds like. It starts at a point, and will attempt to get each element nearby that shares a characteristic, while ignoring those that do not (flooding over an area until that area is filled). In our case, you can think of it like checking for an empty area (floor spaces), and expanding out, until it has found the maximum bounds of that area. At the end, we will have a list of all tiles in that area, and then the algorithm will move on, looking for the next open space that has not been checked yet.
We start out by defining a few variables, mainly slices to keep track of various things, like the current cavern, the size of the current cavern, and a list of all individual caverns we have found so far. Then, we begin by looping over every Tile element in our GameMap, and grabbing the Tile at each location. You&amp;rsquo;ll notice I&amp;rsquo;m using pointers for everything, including my slices. This makes it much easier, as we are dealing with the actual object, rather than a copy of it.
Once we have a Tile, we use our two new convenience methods from earlier to see if, a) have we already visited this Tile, and b) is this Tile a wall. If either of those are true, we mark this Tile visited, and move on. We keep track of Tiles we&amp;rsquo;ve visited, so as not to double (or more) process them in the future. If a tile has not been visited, and is not a wall, we have found a Tile that is part of a cavern, so we add it to the cavern slice.
While there are Tiles present in the cavern slice, we will attempt to get every valid neighbor of each one. This is the flood in flood fill. Inside our cavern loop, we pop the latest Tile off the slice, make sure we don&amp;rsquo;t have a visited or wall Tile once more, and then mark the Tile as visited (since we will not need to process it after this. We also push it onto the totalCavernArea slice, to keep track of Tiles in this current cavern. Then, we check each of its neighbors, north, south, east and west. If any of those are not visited and not walls, we add them to the current cavern. Then, we loop again, popping off a new Tile, and processing it in the same way.
In this way, we will eventually get every floor tile in the current cavern, and at the end, have a complete representation of that cavern in terms of the floor tiles that compose it. When we have exhausted (filled, to use the algorithms parlance) a cavern, we take that set of Tiles representing the cavern, and append it to the caverns slice, which is a slice of slices. Each sub slice in that slice represents a single complete cavern.
Once we are done here, we should have 12 entries in our caverns slice, one for each cavern present on our map. Keep in mind that you will have a different number.
Nice! We now have a comprehensive list of every cavern in our greater cavern system. At this point, you could do all sorts of neat things, but we&amp;rsquo;re going to stick with our original plan, and fill in all but the largest cavern. This is pretty straight forward, but uses a new (to me at least) Go concept, sorting a slice.
// Sort the caverns slice by size. This will make the largest cavern last, which will then be removed from the list. // Then, fill in any remaining caverns (aside from the main one). This will ensure that there are no areas on the // map that the player cannot reach. sort.Sort(BySize(caverns)) mainCave := caverns[len(caverns) - 1] caverns = caverns[:len(caverns) - 1] for i := 0; i &amp;lt; len(caverns); i&#43;&#43; { for j := 0; j &amp;lt; len(caverns[i]); j&#43;&#43; { caverns[i][j].Blocked = true caverns[i][j].Blocks_sight = true } } In order to sort our caverns slice, we&amp;rsquo;ll need to define some custom logic. We want to sort it by the size of the sub slice, smallest to largest, so we can just pop off the last element of the slice, and be sure we have the largest cavern. In order to properly do this, we&amp;rsquo;ll need to define a new type to sort by, called BySize:
type BySize [][]*Tile func (s BySize) Len() int { return len(s) } func (s BySize) Swap(i, j int) { s[i], s[j]= s[j], s[i] } func (s BySize) Less(i, j int) bool { return len(s[i]) &amp;lt; len(s[j]) } Our new type is a 2D slice of Tile pointers, just like our caverns slice. We then define three functions attached to it, to allow for our comparisons. This code is all pretty self explanatory, so I&amp;rsquo;ll leave it at that. Suffice it to say, that when we call sort.Sort() and pass in our new sorting type and our caverns array, it will return a neatly sorted array of caverns, from smallest to largest. Then, we simply just pull the largest cavern off the caverns array, and then systematically fill in the rest.
This leaves us with a single, connected cavern:
Now, all we need to do is place out player in a valid location within the main cave:
// Finally, choose a starting position for the player within the newly created cave pos := rand.Int() % len(mainCave) return mainCave[pos].X, mainCave[pos].Y And that&amp;rsquo;s that. Lets call our new method in our main file, in our init function, so our cave will be the default map:
// Create a GameMap, and initialize it (and set the player position within it, for now) gameMap = &amp;amp;gamemap.Map{Width: MapWidth, Height: MapHeight} gameMap.InitializeMap() playerX, playerY := gameMap.GenerateCavern() player.X = playerX player.Y = playerY Now, when you fire up the game, you should have a sweet, random cave to explore every time! I would like to note that my cave in my example is a little lackluster, as it didn&amp;rsquo;t generate the largest cave possible, but that&amp;rsquo;s the beauty of procedural generation. I find that the caves are quite complex if done on a much bigger map. My example is 100x35, but here&amp;rsquo;s some examples on a 200x200 map:
The variety it can create is pretty neat
I&amp;rsquo;m generally pretty happy with the results
So, that&amp;rsquo;s it, we now have an exciting map for our player to explore and get lost in. As I mentioned earlier, play around with various knobs on the algorithms (number of passes, percentages, ratios, etc), and see what works best. By tweaking a few small things, you can get drastically different results. As usual, if you want to see the full code for this post, you can find it in my repo
Be sure and join me next time when we&amp;rsquo;ll be tackling field of vision, so not only can our player get lost, they can get lost in the cold, lonely, dark. Until next time, happy developing!
This way to Week 5
]]></content:encoded>
    </item>
    <item>
      <title>RLDBAR Sidenote #1: Cameras</title>
      <link>https://jeremyceri.se/post/sidenote-1-cameras/</link>
      <pubDate>Thu, 06 Jul 2017 04:14:21 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/sidenote-1-cameras/</guid>
      <description>This is the first of what I anticipate to be several sidenotes to the main RoguelikeDev Builds a Roguelike shenanigans. These sidenotes will deal with things that are not covered in the main tutorial, but I still feel add value, either to gameplay, programming knowledge, or both. For the inaugural Sidenote, we&amp;rsquo;ll be discussing adding a camera to our in progress roguelike. A camera will give us a couple of benefits, but the most immediate is that we can support maps larger than the terminal window.</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[This is the first of what I anticipate to be several sidenotes to the main RoguelikeDev Builds a Roguelike shenanigans. These sidenotes will deal with things that are not covered in the main tutorial, but I still feel add value, either to gameplay, programming knowledge, or both. For the inaugural Sidenote, we&amp;rsquo;ll be discussing adding a camera to our in progress roguelike. A camera will give us a couple of benefits, but the most immediate is that we can support maps larger than the terminal window. Impossibly large maps for our player to get lost in sounds great.
I&amp;rsquo;m going to try to keep this short, as its not a large topic, so here we go!
Lets briefly discuss our motivations, and the expected outcomes from what we&amp;rsquo;re about to do. Currently, our player is confined to a world that is no bigger than the screen it is contained within. If you move your player outside the bounds of the screen, it just disappears into an inky black abyss. This is fine if we want to have small levels, and contain the player from going off screen (like we currently do). But, what if we wanted bigger maps? Wouldn&amp;rsquo;t it be super nice to make a gigantic map, and only display the portion that the player can immediately see? Having scrolling maps certainly seems like it would add a lot to our game, in the long term. More content is never a bad thing.
So, what we want is the ability to create maps of an arbitrarily large size. We also want to display only the portion of that large map the player can currently see (so, within the bounds of the game window). We&amp;rsquo;ll need to move the camera to follow the player, and as the player moves through the world, make sure we are only displaying the portion of the map that can currently be seen. Sounds like a lot of work, but in practice, its actually quite simple.
What we&amp;rsquo;re going to do is create a GameCamera object that will always have the player at the center. As the player moves around the map, we will update the camera to keep the player in the center, and then we will draw any GameEntities and Tiles that would currently be displayed, based on the players current position. We will need a way to translate coordinates from the camera to the map, as the map will be much larger than the cameras view area.
Lets get started with creating a new package, called &amp;lsquo;camera&amp;rsquo;, that will contain our GameCamera:
package camera type GameCamera struct { X int Y int Width int Height int } Our GameCamera has four basic properties: an (x, y) coordinate set, which will keep track of where the camera currently starts its viewport from, and a Width and Height. Nice and simple. Next, we need a way to &amp;ldquo;move&amp;rdquo; the camera around when the player moves:
func (c *GameCamera) MoveCamera(targetX int, targetY int, mapWidth int, mapHeight int) { // Update the camera coordinates to the target coordinates  x := targetX - c.Width / 2 y := targetY - c.Height / 2 if x &amp;lt; 0 { x = 0 } if y &amp;lt; 0 { y = 0 } if x &amp;gt; mapWidth - c.Width { x = mapWidth - c.Width } if y &amp;gt; mapHeight - c.Height { y = mapHeight - c.Height } c.X, c.Y = x, y } &amp;lsquo;targetX&amp;rsquo; and &amp;lsquo;targetY&amp;rsquo; here are the current position of the player. The (x, y) position of our camera is the top left corner of a rectangle (of size width x height) centered on the player. So, in the first two lines, we take half the width and half the height, and subtract the players x and y, respectively. Next, we check for a few edge cases (literally). If the position of the camera is ever beyond the edges of the map (x &amp;lt; 0, y &amp;lt; 0 or x &amp;gt; mapWidth, y &amp;gt; mapHeight), we&amp;rsquo;ll want to bound the camera to the nearest edge. For example, the player has moved to the far edge of the map, and the distance between the player and the edge is less than half the cameras width. In this case, we will stop moving the camera, and the player will appear to move towards the wall, without the game world shifting; the camera is effectively locked on the edge of the world.
Great, we have a way to move the camera. Now, we need a way to translate coordinates from the map to the camera, as the map will be larger than the camera. Lets take a quick look at that:
func (c *GameCamera) ToCameraCoordinates(mapX int, mapY int) (cameraX int, cameraY int) { // Convert coordinates on the map, to coordinates on the viewport 	x, y := mapX - c.X, mapY - c.Y if x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= c.Width || y &amp;gt;= c.Height { return -1, -1 } return x, y } This function takes a set of map coordinates, and translates them to camera coordinates. We accomplish this by simply subtracting the map coordinates from the width and height of the camera, respectively. This will give us a set of coordinates, that we can then test to see if it is within the current view of the camera. If it is not, we&amp;rsquo;ll return (-1, -1), so it will not be drawn to the screen (we&amp;rsquo;ll be calling this function before we draw anything in the game, henceforth).
That about does it for our GameCamera struct. Lets take a look at how to go about using it!
The first thing we&amp;rsquo;ll do is to set our MapWidth and MapHeight consts to 200 each. Because why not? Large maps are fun. Next, we&amp;rsquo;ll need to add a new variable to represent our camera:
var ( ... gameCamera *camera.GameCamera ) Then, in our init() function, we need to initialize our new camera:
func init() { ... // Initialize a camera object  gameCamera = &amp;amp;camera.GameCamera{X: 1, Y:, Width: WindowSizeX, Height: WindowSizeY} } I&amp;rsquo;ve initialized the initial camera position to (1, 1). This won&amp;rsquo;t matter, as we&amp;rsquo;ll quickly be changing that once the player starts moving. I&amp;rsquo;ve also, for now, set the width and height of the camera to match the size of the window.
Next up, lets actually implement our camera. In our renderAll() function, add the following line before the rest of the code:
gameCamera.MoveCamera(player.X, player.Y, MapWidth, MapHeight) At this point, when we are calling renderAll(), we have already determined if the player has moved, and as such, should have new coordinates for it (or not, in which case we still have the players x, y coordinates regardless). We feed those into the MoveCamera() function, which will update the position of the camera to center the player (if it can; remember, if the player is near the map edge, it will not end up centered). Once we have moved the camera, we can go along rendering as normal.
Now, we&amp;rsquo;ve got a bit of house keeping to do. We need to update our GameEntities Draw() and Clear() functions to use camera coordinates, instead of map coordinates. Remember, if a GameEntity is outside of the bounds of the camera, we just won&amp;rsquo;t draw it. Lets modify our renderEntities() function as follows:
func renderEntities() { // Draw every Entity present in the game. This gets called on each iteration of the game loop. 	for _, e := range entities { cameraX, cameraY := gameCamera.ToCameraCoordinates(e.X, e.Y) e.Draw(cameraX, cameraY) } } This will give us the coordinates within the cameras view that the GameEntity will appear (or not, if its outside the screen). We&amp;rsquo;ll need to do the same thing before we call Clear() in our main game loop:
// Clear each Entity off the screen for _, e := range entities { mapX, mapY := gameCamera.ToCameraCoordinates(e.X, e.Y) e.Clear(mapX, mapY) } Now that we&amp;rsquo;re drawing our entities to the correct locations, lets look at what we need to change to properly draw the map (or rather, the portion of the map the camera can see):
func renderMap() { // Render the game map. If a tile is blocked and blocks sight, draw a &amp;#39;#&amp;#39;, if it is not blocked, and does not block 	// sight, draw a &amp;#39;.&amp;#39; 	for y := 0; y &amp;lt; gameCamera.Height; y&#43;&#43; { for x := 0; x &amp;lt; gameCamera.Width; x&#43;&#43; { mapX, mapY := gameCamera.X &#43; x, gameCamera.Y &#43; y if gameMap.Tiles[mapX][mapY].Blocked == true { blt.Color(blt.ColorFromName(&amp;#34;gray&amp;#34;)) blt.Print(x, y, &amp;#34;#&amp;#34;) } else { blt.Color(blt.ColorFromName(&amp;#34;brown&amp;#34;)) blt.Print(x, y, &amp;#34;.&amp;#34;) } } } } As you can see, we&amp;rsquo;re now using the GameCamera as the basis for our drawing loop. We only want to draw things that appear within the bounds of the camera, so we only loop over the width and height of the camera, rather than the map. We then add the camera X and Y to the current x and y to get the actual map tile, and then we render the tile as usual. This works because the GameCamera will be a rectangle centered on the player, so GameCamera.X &#43; x will give us the actual map location, as it simply applies the offset. If the GameCamera is currently at (2, 2), the first time through the loop, mapX and mapY would be (2, 2) (since x and y are 0). The next time around, mapX and mapY would be (3, 2), as we are now at y = 0, x= 1. Hopefully, you can follow that example along and convince yourself of what this is doing (since I&amp;rsquo;m not very good at explaining it).
Alright, that should be everything. We have a new GameCamera struct, which we are moving around each time the player moves, keeping the player centered inside it. We translate all of our draw calls to coordinates the camera can use, and we only draw the portions of the map that the camera can see. Awesome. If you fire up your game and start moving your player around, you should notice that as soon as the player moves beyond the center of the screen along either axis, the NPC, as well as the walls, will move out of sight slowly. And you should be able to move all 200 spaces to the other side of the room!
The code for this sidenote can be found on release v0.0.4 on my github. Next time, we&amp;rsquo;ll be back on the main tutorial track with dungeon generation! Until then, happy developing!
]]></content:encoded>
    </item>
    <item>
      <title>RoguelikeDev Builds A Roguelike, Part 3</title>
      <link>https://jeremyceri.se/post/roguelike-dev-week-1-part-2/</link>
      <pubDate>Mon, 03 Jul 2017 02:25:13 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/roguelike-dev-week-1-part-2/</guid>
      <description>Welcome back to my series following along with RoguelikeDev Builds a Roguelike! This is the second part of this weeks posts, the first being concerned with creating a player representation and moving it around using player input. In the second part of this week, we&amp;rsquo;re going to start thinking about the overall structure of our game, as well as get an intial version of the gameplay map, which is the world the player will be interacting with.</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[Welcome back to my series following along with RoguelikeDev Builds a Roguelike! This is the second part of this weeks posts, the first being concerned with creating a player representation and moving it around using player input. In the second part of this week, we&amp;rsquo;re going to start thinking about the overall structure of our game, as well as get an intial version of the gameplay map, which is the world the player will be interacting with. We&amp;rsquo;ll accomplish this using the idea of an &amp;lsquo;Entity&amp;rsquo;, and applying that to (almost) eveverything in our game.
Lets go!
If you recall from last time, we were creating a set of player coordinates, playerX, and playerY, and the applying those to a function, drawPlayer(), which would, when given the coordinates and a character to represent the player, draw the player to the screen. We could then update those coordinates to move the player around. This worked fine, but lets consider a few things, primarily, how do we go about drawing a large number of different things to the screen? Enemies, items, traps, flora, fauna, etc? Surely, we could (extremely) naively create variables for each of them, and draw them out one by one like we do for the player, but that sounds awful. What we really need is some way to represent a generic &amp;ldquo;thing&amp;rdquo; in our game. Every &amp;ldquo;thing&amp;rdquo; has some common properties, like a location, a character, and a color. So, what we really want to do, is make every thing the player sees and interacts with (including the player!) a &amp;ldquo;thing&amp;rdquo;.
Henceforth, I&amp;rsquo;m going to use the term Entity to refer to anything in our game (with a few exceptions we&amp;rsquo;ll get to later in this post). An Entity will have an (x, y) location, a color, and a character. This will allow us to create as many Entities as we want, to represent anything in our game. The player is a white @, an orc could be a dark green O, a purple dragon could be a purple D, a scroll of fireball a beige |, and so on and so forth. Using the idea of Entities allows us a great deal of flexibility. I could go on about object oriented design here, but these posts are not meant to deal with that, so go read up on it if you&amp;rsquo;re curious.
Okay, so our plan is to create an Entity representation, and make everything in our game an Entity. Lets see how to do that. Before I get into the code and specifics, I would like to say that this is going to be one of many &amp;ldquo;Great Refactors&amp;rdquo; throughout the course of this series. Refactoring your code from time to time is healthy and natural, and the ladies love it. Anyways&amp;hellip;
Go does not have a traditional Class representation that many other object oriented languages have. This was one of the first major differences in Go that I had to wrap my head around. Lacking classes, though, Go does provide us two very powerful things: structs, and interfaces. We&amp;rsquo;ll get into interfaces later, and for now we&amp;rsquo;re going to focus on structs. For all intents and purposes (read: as far as I have found), a struct in Go is more or less parallel to the class keyword you may be familiar with in other languages. It allows you to define fields for the given struct, and then associate methods with that struct. Sounds like a class with a different name. For our purposes, it provides exactly what we need: a way to encapsulate some functionality in a reusable way. Enough talking, lets write some code.
I created a new package at this point, as I like to have tidy code; you are more than welcome to include this in your main game file, either way works. In my new package, entity, I created a file called entity.go. The first thing we&amp;rsquo;ll need to do is create our struct:
type GameEntity struct { X int Y int Layer int Char string color string } That&amp;rsquo;s it. Pretty simple. You may notice that each member variable starts with a capital letter. Good eye. In Go, to make something public (accessible outside of the scope where it was defined), you begin the name with a capital letter. To make it private (accessible only within its defining scope), you begin its name with a lowercase letter. I chuckled to myself when I learned this, because its wonderfully simple, and easy to read at a glance. I like Go for small details like this. Anyways, we&amp;rsquo;ll need to access these variables outside of the scope of the struct, so I made them all public (for now). X and Y will represent the location of the Entity, Layer will represent the current rendering layer for BearLibTerminal (more on that later), Char is the character we want to visually represent the Entity, and Color is what color it will be displayed as. Pretty straight forward stuff.
Now that we have our struct representing our Entity, lets make sure it has feature parity with our current player code. To do that, we&amp;rsquo;ll need some way to draw it to the screen, as well as move it around. For good measure, we should also have a method to clear it from the screen (in case it dies, is destroyed, turns invisible, or we just need to re-draw the screen). We&amp;rsquo;re going to create three functions, and associate them with our Entity struct:
func (e *GameEntity) Move(dx int, dy int) { // Move the Entity by the amount (dx, dy)  e.X &#43;= dx e.Y &#43;= dy } func (e *GameEntity) Draw() { // Draw the Entity to the screen  blt.layer(e.Layer) blt.Color(blt.ColorFromName(e.Color)) blt.Print(e.X, e.Y, e.Char) } func (e *GameEntity) Clear() { // Remove the entity from the screen  blt.Layer(e.Layer) blt.Print(e.X, e.Y, &amp;#34; &amp;#34;) } Lets start with Move() (again, notice the uppercase first letter, meaning its a public method). Our function declaration looks a little different than others we&amp;rsquo;ve seen in the past, mainly due to the
(e *GameEntity) bit that&amp;rsquo;s hanging out in the signature. This is how we &amp;ldquo;associate&amp;rdquo; a function with a struct. We&amp;rsquo;re basically saying that the function expects to have access to a variable named &amp;ldquo;e&amp;rdquo;, which is of type GameEntity. The closest comparison I can draw to this is Pythons &amp;lsquo;self&amp;rsquo;, if you&amp;rsquo;re familiar with how that works. It says, this method is to be used on the struct type I specify. This method can then be called using dot notation, with the object calling being passed in as &amp;ldquo;e&amp;rdquo;. Not too deviant. Anyways, on to the Move() function.
Move() takes two arguments, dx, and dy. These represent the change in X and Y, respectively (deltaX, and deltaY is another way to think of it). We take these deltas, and apply them to the Entities X and Y, thus altering its position. If we pass in dx: 0, dy: -1, we&amp;rsquo;re moving the Entity up the screen by one (Since our coordinate system has (0,0) in the top left corner). If we pass in dx: 1, dy: 0, we&amp;rsquo;re moving the Entity to the right by one, etc. This is a simple and effective way to move our Entity around the screen.
Next up is Draw(). This code should look familiar from our drawPlayer() function last time; its the same code, with a few minor changes. We&amp;rsquo;re using our struct (&amp;ldquo;e&amp;rdquo;) instead of hardcoding values. It sets the Layer (there&amp;rsquo;s that pesky Layer thing again, I&amp;rsquo;m going to have explain it at some point&amp;hellip;but that&amp;rsquo;s a problem for future me), then sets the color, both from the structs values, and finally, calls Print() to print the whole thing to screen.
Finally, Clear(). Again, it sets the Layer, and then simply replaces the character on the terminal with an empty space. This effectively &amp;ldquo;erases&amp;rdquo; the Entity from the screen. We&amp;rsquo;ll see in a bit how this will be handy.
Alright, that does it for our GameEntity struct! Now, lets see how we can use it.
The first thing we need to do is import our new package (skip this if you didn&amp;rsquo;t create a new package for our Entity struct):
import ( blt &amp;#34;bearlibterminal&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;entity&amp;#34; ) Next, lets define a couple of handy variables:
var ( player *entity.GameEntity entities []*entity.GameEntity ) We&amp;rsquo;re defining two variables, player and entities. Player will, predictably, keep track of our player Entity. Entities will be a slice (Go for ArrayList) of type GameEntity (Entity, since I can&amp;rsquo;t keep my references in this blog post straight, sorry about that). You may also notice a &amp;lsquo;*&amp;rsquo; in front of the struct type. In Go, that denotes that we are making these as pointers to the type, in this case entity.GameEntity. Pointers are beyond the scope of this series, but I&amp;rsquo;ll do my best to explain why we&amp;rsquo;re doing this as I go.
Now, lets modify our init() function to create a couple of entities:
func init() { ... // Create a player Entity, and an NPC Entity, and add them to our slice of Entities  player = &amp;amp;entity.GameEntity{X: 1, Y: 1, Layer: 1, Char: &amp;#34;@&amp;#34;, Color: &amp;#34;white&amp;#34;} npc := &amp;amp;entity.GameEntity{X: 10, Y: 10, Layer: 0, Char: &amp;#34;N&amp;#34;, Color: &amp;#34;red&amp;#34;} entities = append(entities, player, npc) } The player variable gets assigned to an Entity, and we create a new variable called NPC to represent a second entity. Again, there&amp;rsquo;s a bit of new notation in these variable assignments, the &amp;lsquo;&amp;amp;&amp;rsquo; in front of the name. This denotes that we are going to use the value assigned by reference, rather than by value. Basically, a pointer at the object created. The upshot of this is that, later in the code, when we modify something on the player Entity, it will be updated on the original player, in the way we expect. If we had created this variable by value, we would have gotten a copy assigned, and trying to modify it later would modify the copy, rather than the original, not what we want. Pointers 101 dismissed.
The last step here is to append both the player and NPC Entities to our entities slice, so we can keep track of them. Because we created them by reference, the variables in the slice will point to our original objects.
Three steps left: create a function to draw all our of entities to the screen at once, update our movement controls to use our new Entity struct, and update our game loop to in the same manner. Lets start by creating a function to draw all our entities to the screen:
func renderEntities() { // Draw every Entity present in the game. This gets called on each iteration of the game loop.  for _, e := range entities { e.Draw() } } Because we have a central Draw() method with our struct, we can simply iterate over the entities slice, and call Draw() on each one. This will draw the Entity to the screen at its current (X, Y) position. Nice! As a side note, this is Go&amp;rsquo;s version of a for each loop. We&amp;rsquo;re saying use a blank placeholder (_) for the index, since we don&amp;rsquo;t care about that, and assign each Entity in entities to e.
Next, lets update our movement controls to use our Entity struct:
func handleInput(key int) { // Handle basic character movement in the four main directions  var ( dx, dy int ) switch key { case blt.TK_RIGHT: dx, dy = 1, 0 case blt.TK_LEFT: dx, dy = -1, 0 case blt.TK_UP: dx, dy = 0, -1 case blt.TK_DOWN: dx, dy = 0, 1 } player.Move(dx, dy) } We set a couple of ints, dx and dy, which should look familiar from our Move() method on our struct, and then we assign what they should be based on the key input (the logic is more or less the same as before). Finally, we call player.Move(), with the new values. Done.
Finally, lets tweak our main game loop to put all of this together:
func main() { // Main game loop  renderEntities() for { blt.Refresh() key := blt.Read() // Clear each entity off the screen, so we can re-draw them  for _, e := range entities { e.Clear() } if key != blt.TK_CLOSE { handleInput(key) } else { break } // Re-draw all of our Entities, since they may have moved  renderEntities() } blt.Close() } First up, we draw every Entity to the screen (this will initialize our game screen when the game first starts). Then we go into our main game loop, which refreshes the screen, and checks if any input was used. Then, we clear all the Entities, since they may be about to move. Finally, we handle any input, and then re-draw everything in its new (maybe) positions.
Whew! That was a lot of work, but at this point, we have a working generic implementation that will allow us to create as many Entities as we want, and draw them all to the screen. Pat yourself on the back, that was no mean feat.
Now, lets create a world for these Entities to reside in.
The first thing I&amp;rsquo;m going to do is create a new package (yes, I like packages) called &amp;lsquo;gamemap&amp;rsquo;. This is going to contain our world building logic. Inside this package, lets create a file called gamemap.go. In this file, lets define a new struct, called Tile:
type Tile struct { Blocked bool BlocksSight bool } This struct will represent a single tile in our map (which, if you haven&amp;rsquo;t guessed yet, is a grid of tiles). It has two properties we care about for a map tile: whether the Tile blocks movement, and whether the Tile blocks sight. A floor Tile should block neither sight nor movement, as Entities should be able to move about on them. A wall Tile should block both sight and movement, as you can&amp;rsquo;t more, nor see, through walls. A chasm Tile might block movement, but not sight, and a cloud of smoke might block sight but not movement.
Next, lets create another struct, called GameMap:
type GameMap struct { Width int Height int Tiles [][]*Tile } Our GameMap will keep track of how wide and tall it is, as well as containing a 2D array of Tiles. Since we are working on a 2D grid, a 2D array makes perfect sense for storing our map data. The outer array will represent the x coordinates, and the inner, the y. It will be easy to access a given Tile inside the map array like map[x][y].
We&amp;rsquo;re going to define two functions to attach to the GameMap struct, one to initialize it, and one to check if a tile blocks movement or not. The first, initialization, will be a temporary bit of logic, to make sure everything is working, and give us something quick to play with. We&amp;rsquo;re going to outline the screen with wall Tiles, and fill in the interior with floor Tiles. This will make a large, screen sized room for the player to roam around in, and will nicely exemplify our movement blocking mechanics.
func (m *GameMap) InitializeMap() { // Set up a map where all the border (edge) Tiles are walls (block movement, and sight) 	// This is just a test method, we will build maps more dynamically in the future. 	m.Tiles = make([][]*Tile, m.Width) for i := range m.Tiles { m.Tiles[i] = make([]*Tile, m.Height) } for x := 0; x &amp;lt; m.Width; x&#43;&#43; { for y := 0; y &amp;lt; m.Height; y&#43;&#43; { if x == 0 || x == m.Width- 1 || y == 0 || y == m.Height- 1 { m.Tiles[x][y] = &amp;amp;Tile{true, true} } else { m.Tiles[x][y] = &amp;amp;Tile{false, false} } } } } We&amp;rsquo;re using Go&amp;rsquo;s built in Make to initialize our Tile array, with an outer length of the Width of the map. Then, we begin to iterate over each outer cell. In each X cell, we create a new array of length Height. This gives us a fully initialized 2D array of size (Width x Height). We then iterate over each cell in the 2D array, and check two things: Is x or y equal to zero, or is x equal to the width of the map - 1 or y equal to the height of the map -1. If it is, we know we are on an edge (either the right or left edge, or the top or bottom). If this is true, we want this Tile to be a wall Tile, so we create a new Tile that both blocks sight and movement. If this check fails, we create a floor Tile (does not block sight nor movement).
At the end of this method, we should have a (Width x Height) 2D array that is filled with wall and floor Tiles.
Next, lets write a function to check if a given Tile is blocked:
func (m *Map) IsBlocked(x int, y int) bool { // Check to see if the provided coordinates contain a blocked tile 	if m.Tiles[x][y].Blocked { return true } else { return false } } This function simply takes an (x ,y) coordinate pair, and returns if the Tile, at that coordinate in the GameMap, has the Blocked property set to true. We&amp;rsquo;ll use this a little later to determine where the player can and can&amp;rsquo;t move.
Alright, that should do it for our gamemap package! Now lets go implement what we have in the rest of our program.
In our main file, we need to: import our gamemap package (skip if you did not create a package), create a new variable to represent and track our GameMap, initialize our map, and finally, draw our map to the screen. Sounds like a lot of work, lets get to it.
First, import our package:
import ( blt &amp;#34;bearlibterminal&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;entity&amp;#34; &amp;#34;gamemap&amp;#34; ) We also need to add a couple of constants to set our map width and height. For now we&amp;rsquo;ll just use the window width and height, but in the future, our maps will be much larger than the window:
const ( WindowSizeX = 100 WindowSizeY = 35 MapWidth = WindowSizeX MapHeight = WindowSizeY Title = &amp;#34;BearRogue&amp;#34; Font = &amp;#34;fonts/UbuntuMono.ttf&amp;#34; FontSize = 24 ) Next, we need to add a new var that will store our GameMap:
var ( player *entity.GameEntity entities []*entity.GameEntity gameMap *gamemap.Map ) Then, we need to set and initialize our new gameMap variable in our init() function:
func init() { ... // Create a GameMap, and initialize it  gameMap = &amp;amp;gamemap.Map{Width: MapWidth, Height: MapHeight} gameMap.InitializeMap() } Now that we have that done, we need a way to actually draw our map to the screen. We&amp;rsquo;re going to create a new function, renderMap, that will iterate over each Tile in our GameMap, and Print it to the screen. This will happen before we render our Entities, so the entities are rendered on top of the map. This is where we actually assign characters to the wall (&amp;quot;#&amp;quot;) and floor (&amp;quot;.&amp;quot;) Tiles. I will also be setting a color for each one:
func renderMap() { // Render the game map. If a tile is blocked and blocks sight, draw a &amp;#39;#&amp;#39;, if it is not blocked, and does not block  // sight, draw a &amp;#39;.&amp;#39;  for x := 0; x &amp;lt; gameMap.Width; x&#43;&#43; { for y := 0; y &amp;lt; gameMap.Height; y&#43;&#43; { if gameMap.Tiles[x][y].Blocked == true { blt.Color(blt.ColorFromName(&amp;#34;gray&amp;#34;)) blt.Print(x, y, &amp;#34;#&amp;#34;) } else { blt.Color(blt.ColorFromName(&amp;#34;brown&amp;#34;)) blt.Print(x, y, &amp;#34;.&amp;#34;) } } } } This function is pretty simple. All it does is loop over each Tile in the 2D array, and check the Blocked method from the GameMap struct to see if the Tile is a floor or Wall. It then prints the appropriate symbol and color.
Great, so now we have initialized our map, and can draw it. Whats left? Well, actually drawing the map! I&amp;rsquo;m going to create a new, simple convenience method to render everything (GameMap and Entities) at once, so we only have to call one function in our game loop, instead of two. Clean code is happy code.
func renderAll() { // Convenience function to render all entities, followed by rendering the game map 	renderMap() renderEntities() } As discussed above, renderAll() calls renderMap() first, followed by renderEntities(), as we want the Entities rendered on top of the map. Now, we just modify our game loop to include this method:
func main() { // Main game loop  renderAll() for { blt.Refresh() key := blt.Read() // Clear each Entity off the screen 	for _, e := range entities { e.Clear() } if key != blt.TK_CLOSE { handleInput(key, player) } else { break } renderAll() } blt.Close() } Notice that all we changed was swapping out the renderEntities() calls for renderAll() calls. This means that we re-draw the entire map and Entity list every time through the game loop.
Done and done! If you run this now, you should see what resembles a large room, with our &amp;lsquo;@&amp;rsquo; player (movable, of course), and an (for now) immobile NPC. You should be able to bump into the walls, but not move through, and move freely across the floor.
We accomplished quite a bit in this post, and our &amp;ldquo;game&amp;rdquo; is starting to actually resemble something playable at this point. To recap, we added an Entity struct to represent every object in the game (except map objects, which are represented by a Tile struct). We refactored our main game code to use this new struct by making our player, plus a new NPC, as Entities. Finally, we created a GameMap struct which stores information about the map the player moves around on, and initialized it to an empty room, making sure that the player cannot pull a magic act and move through walls (yet&amp;hellip;). As usual, you can find all the code for this post under the v0.0.3 release on my github repo.
Join me next week when we&amp;rsquo;ll talk about fleshing out our map to make it more&amp;hellip;dungeony. Until then, happy developing!
This way to Part 4
=====
Sidenote for this post: Sidenote 1: Cameras
]]></content:encoded>
    </item>
    <item>
      <title>RoguelikeDev Builds a Roguelike, Part 2</title>
      <link>https://jeremyceri.se/post/roguelike-dev-week-1-part-1/</link>
      <pubDate>Wed, 28 Jun 2017 04:33:11 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/roguelike-dev-week-1-part-1/</guid>
      <description>Welcome back to my series following along with RoguelikeDev Builds a Roguelike! This is part 2, and this week, we&amp;rsquo;ve got things split into two parts. The first part, which this post will be concerned with, involves displaying the player and the screen, and implementing basic four direction movement. Part two will consist of creating a generic &amp;lsquo;Object&amp;rsquo; type that will represent things in the game, as well as creating an initial dungeon map.
Lets dive right in creating our player, and getting it moving!
</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[Welcome back to my series following along with RoguelikeDev Builds a Roguelike! This is part 2, and this week, we&amp;rsquo;ve got things split into two parts. The first part, which this post will be concerned with, involves displaying the player and the screen, and implementing basic four direction movement. Part two will consist of creating a generic &amp;lsquo;Object&amp;rsquo; type that will represent things in the game, as well as creating an initial dungeon map.
Lets dive right in creating our player, and getting it moving!
We left off last week with a terminal window, displaying some basic &amp;ldquo;Hello, World!&amp;rdquo; text. Certainly not the most exciting thing in the world, and in fact quite a ways from a playable game, but progress none-the-less. This time around, lets actually make it so that the player can interact with the game itself, in the form of moving a representation of the player around the screen.
The first thing we&amp;rsquo;re going to need to do is come up with a way to reliably print a character representing the player to the screen. In this case, we will use the classic roguelike standby, the &amp;lsquo;@&#39;. We&amp;rsquo;ve already gone over how to print things to the screen last week, using BearLibTerminals Print() method. We could certainly do something like:
blt.Print(1, 1, &amp;#39;@&amp;#39;) This would print out player character to the screen at coordinates (1, 1), or the top left corner of the screen. Its easy enough to replace the code that prints &amp;ldquo;Hello, World!&amp;rdquo; with this code, and call it good, but what if we want to move the player around (which we do)? Well, just printing it over and over into the same place certainly won&amp;rsquo;t help us there, so we&amp;rsquo;ll need to store some information about the players location within our game world. Lets add a couple of new variables to our program:
var ( playerX = 0 playerY = 0 ) We&amp;rsquo;ll use these two variables to keep track of where the player is in the game world. A quick note, these are globally defined, which in my opinion is generally a no-no, so we&amp;rsquo;ll be cleaning them up later, but for now, this is fine.
So, we&amp;rsquo;ve got our players location stored, and we can now use that to print the player character wherever the coordinates say. What we want now, is to use those new variables to update the players position whenever arrow keys are pressed. For example, if the player presses the UP arrow key, we would expect that the players &amp;lsquo;@&amp;rsquo; will move towards the top of the screen. This may sound a little tough, but in reality its quite simple. Since BearLibTerminal gives us a nice grid to work with (and we can assume that each square in the grid is 1x1), all we need to do is move the player by 1 unit in the desired direction, when an arrow key is pressed.
To elaborate a bit more, when the player presses UP, we want to adjust playerY - 1, and when they press DOWN, we want to adjust playerY &#43; 1. Likewise, when they press LEFT, we would adjust playerX - 1, and when RIGHT is pressed, playerX &#43; 1. Hopefully this is obvious, but if not, we are simply moving the player around on an inverted two dimensional (x, y) plane ( (0, 0) is at the top left corner, rather than the bottom left, as you might expect). If we move towards the top of the screen, the y value of the point (our player) is decreasing, and approaching 0. If we move towards the bottom of the screen, our y value is increasing, and approaching WindowSizeY. Same for the x values: left is decreasing, and approaching 0, right is increasing and approaching WindowSizeX.
To tie this all together, we simply need to handle the key presses from the arrow keys, which, as we&amp;rsquo;ve already seen, can be done in BearLibTerminal using the Read() method. Lets create a new method to handle this, that takes in the value returned by the Read() method:
func handleInput(key int) { switch key { case blt.TK_RIGHT: playerX &#43;&#43; case blt.TK_LEFT: playerX -- case blt.TK_UP: playerY -- case blt.TK_DOWN: playerY &#43;&#43; } } The Read() method simply returns an integer, which we can then map back to one of BearLibTerminals key event types. The switch statement simply checks which key was pressed, and following our logic from earlier, adjusts the playerX and playerY values accordingly. Pretty simple!
Now, we&amp;rsquo;ve got a way to update the position of our player, lets add a new function that will draw the player the screen, using the playerX and playerY variables. This is going to be a convenience method, so we can clean up our code a bit. BearLibTerminal has a concept of layers when it draws, which is something that I will go into in more detail in a later post, but suffice it to say, much like setting the color we are printing to the terminal, we can also specify which layer we are working with. There is also a method that will clear everything from a specified area (which in our case, currently, is the entire screen). We will use this to clear the entire screen, and then re-draw our player at the specified position. Don&amp;rsquo;t worry if you don&amp;rsquo;t understand the concepts of layers and drawing, as we&amp;rsquo;ll get more in depth into that at a later time. Lets add a function called drawPlayer:
func drawPlayer(x int, y int, symbol string) { blt.Layer(0) blt.ClearArea(0, 0, WindowSizeX, WindowSizeY) blt.Print(playerX, playerY, symbol) } We select the layer (0, in this case, is our only layer), we clear the screen from position (0, 0) to (WindowSizeX, WindowSizeY), which is our entire gameplay area for now, and then we Print() the players character, setting it at the current values of playerX and playerY.
Okay, we&amp;rsquo;ve now got a way to get player input, and adjust the position of the players character, and a way to easily clear the screen, and re-draw the player at the updated position. The final step here is to put it all together in our main game loop:
func main() { blt.Color(blt.ColorFromName(&amp;#34;white&amp;#34;) drawPlayer(playerX, playerY, &amp;#34;@&amp;#34;) for { blt.Refresh() key := blt.Read() if key != blt.TK_CLOSE { handleInput(key) drawPlayer(playerX, playerY, &amp;#34;@&amp;#34;) } else { break } } blt.Close() } Our main game loop has changed a bit, so lets walk through it. First up, we&amp;rsquo;re setting the color to print as white, same as we did previously. Then, we&amp;rsquo;re drawing the player to the screen, using the playerX and playerY variables (set to (0, 0)). Then we get into our main loop. Each iteration of the loop, we Refresh() the screen, and then call Read() to see if the player pressed a key. If they did, we check to see if it was TK_CLOSE. If it was, we break out of the loop, and exit the game. If it wasn&amp;rsquo;t, we pass it to handleInput(). handleInput only knows how to handle four different keys (the arrow keys), so it will safely ignore any key press that is not an arrow key. If an arrow key was pressed, we adjust the playerX and playerY variables accordingly. Finally, we print the player to the screen (clearing the contents first in the drawPlayer() method) at the new coordinates provided by playerX and playerY. Whew, quite a few changes there!
At this point, you should be able to fire up your game, see the players &amp;lsquo;@&amp;rsquo; sitting in the top left corner, and press an arrow key to move it around. Awesome!
You may notice that as you move your character around, it is possible for it to leave the screen. This is obviously not something we want. Lets go about fixing that. Essentially what we need to do, is if the player would move out of the range of the screen, set it back to the last valid position before it left. To elaborate, if the player is attempting to move to, say, (-1, 0), or just to the left of the edge of the screen, we should set his position back to (0, 0). Likewise, if the player is trying to move to (WindowSizeX &#43; 1, 0), we should probably place the character back at (WindowSizeX, 0). Basically, set the players position to the last valid position they were at before they tried to move. Lets add this code the bottom of our handleInput() function, just below the end of the switch statement:
if playerX &amp;gt; WindowSizeX - 1 { playerX = WindowSizeX -1 } else if playerX &amp;lt; 0 { playerX = 0 } if playerY &amp;gt; WindowSizeY - 1 { playerY = WindowSizeY - 1 } else if playerY &amp;lt; 0 { playerY = 0 } This will stop the player from ever moving beyond the bounds of the screen. Go ahead and try it out, you&amp;rsquo;ll find the player bumps into an invisble wall right at each edge of the screen!
To recap so far: We&amp;rsquo;ve successfully drawn the player to the screen, and can move the character around. We made a function to handle player input, as well as one to draw the player to the screen, at a provided set of coordinates. This is starting to look more like a game already! Next time we&amp;rsquo;ll set up a map for the player to explore, as well as handle some architectural concerns that will make our lives easier once our game starts to grow.
As usual, you can find the full code for this post under the Part 2 release on my repo. See you next time, and happy developing!
This way to Part 3
=====
Sidenote for this post: Sidenote 2: VIM keys and Diagonal Movement
]]></content:encoded>
    </item>
    <item>
      <title>RoguelikeDev Builds a Roguelike, Part 1</title>
      <link>https://jeremyceri.se/post/roguelike-dev-week-0/</link>
      <pubDate>Thu, 22 Jun 2017 05:54:35 UT</pubDate>
      <dc:creator>Jeremy Cerise</dc:creator>
      <guid>https://jeremyceri.se/post/roguelike-dev-week-0/</guid>
      <description>So it begins! This is the first in a series of posts following my attempts at making a Roguelike, in Go, using BearLibTerminal. I&amp;rsquo;ll be following along with the RoguelikeDev builds a Roguelike posts as I progress.
So, without further ado, lets begin part 0: Setup!`
</description>
      <category domain="https://jeremyceri.se/categories/technology">Technology</category>
      <content:encoded><![CDATA[So it begins! This is the first in a series of posts following my attempts at making a Roguelike, in Go, using BearLibTerminal. I&amp;rsquo;ll be following along with the RoguelikeDev builds a Roguelike posts as I progress.
So, without further ado, lets begin part 0: Setup!`
Part 0 is dedicated to setting up your dev environment, and making sure everything is running correctly. There won&amp;rsquo;t be a lot of code this week, although the end result will be a working terminal with the traditional &amp;lsquo;Hello, World!&amp;rsquo; text. As a bonus, we&amp;rsquo;ll display that text in a color other than boring old white.
Since I chose to use Go to write my roguelike in, rather than Python, the very first thing we should do is install Go. Depending on what OS you&amp;rsquo;re using, the process will be a little different, but generally not difficult. I&amp;rsquo;m using Arch Linux, so for me, installing Go simply consisted of:
sudo pacman -S go You can check the docs for specifics on how to get Go installed for your operating system.
Once Go is installed, and you have verified that it works, we&amp;rsquo;ll need to make sure our GOPATH is configured correctly. GOPATH is where Go will look for packages included outside of the main project structure (bear with my explantions, I&amp;rsquo;m still learning Go). Typically, this is set to $HOME/go, and thats where I left it on my system. You can read more about GOPATH here.
The next step is to install BearLibTerminal. BearLibTerminal has a Go package we can use out of the box, and thats what we will be including in our project. Download BearLibTerminal here. Once downloaded and unpacked, we need a few files. We&amp;rsquo;ll need include/BearLibTerminal.Go, and Linux64/LibBearLibTerminal.so, and include/C/BearLibTerminal.h. The C header file is important, as thats what powers the whole library, so don&amp;rsquo;t forget that. We&amp;rsquo;re now going take those files, and place them in GOPATH/src/bearlibterminal. This will allow us to use BearLibTerminal in our project, by simply including it.
Great! Now, we&amp;rsquo;re more or less setup to start developing! A quick note, I&amp;rsquo;m using Gogland, Jetbrains Go IDE (still under active development). Its currently free, but won&amp;rsquo;t remain that way for much longer, I&amp;rsquo;d wager. Any IDE or text editor will do, though.
Lets set up our project. I&amp;rsquo;ve called my project BearRogue (super creative, I know), and my file structure is pretty basic right now.
bearrogue --src/ bearrogue.go --font/ UbuntuMono.ttf --README.md Right, lets get right into it. We need to declare our package, and include BearLibTerminal, first and foremost:
package main import ( blt &amp;#34;bearlibterminal&amp;#34; &amp;#34;strconv&amp;#34; ) If your GOPATH is configured correctly, and you&amp;rsquo;ve put the BearLibTerminal files there as instructed, Go should be able to find BearLibTerminal without any trouble. The strconv package will be used to do some type conversions later.
With our packages included, lets set up some basic constants to make our lives easier:
const ( WindowSizeX = 100 WindowSizeY = 35 Title = &amp;#34;BearRogue&amp;#34; Font = &amp;#34;fonts/UbuntuMono.ttf&amp;#34; FontSize = 24 ) These constants should be pretty straight forward. The two WindowSize constants will set the size of our terminal window, Title sets the text to display in the title bar, Font tells BearLibTerminal what font we want to use, and FontSize what size to render that font. A note, I&amp;rsquo;m using a HDPI display, so adjust these to fit your screen accordingly.
Now that we&amp;rsquo;ve got some constants defined, lets use them to initialize BearLibTerm. I&amp;rsquo;m going to use an init method, as that will be called before our main method. I&amp;rsquo;ll explain whats going after the code snippet:
func init() { blt.Open() // BearLibTerminal uses configuration strings to set itself up, so we need to build these strings here  // First, lets set up the string for window properties (size and title)  size := &amp;#34;size=&amp;#34; &#43; strconv.Itoa(WindowSizeX) &#43; &amp;#34;x&amp;#34; &#43; strconv.Itoa(WindowSizeY) title := &amp;#34;title=&amp;#39;&amp;#34; &#43; Title &#43; &amp;#34;&amp;#39;&amp;#34; window := &amp;#34;window: &amp;#34; &#43; size &#43; &amp;#34;,&amp;#34; &#43; title // Next, set up the font config string  fontSize := &amp;#34;size=&amp;#34; &#43; strconv.Itoa(FontSize) font := &amp;#34;font: &amp;#34; &#43; Font &#43; &amp;#34;, &amp;#34; &#43; fontSize // Now, put it all together  blt.Set(window &#43; &amp;#34;; &amp;#34; &#43; font) blt.Clear() } The first thing we do is Open a new BearLibTerminal:
blt.Open() This initializes a new window for us to use. The next thing we do is set up the window configuration. BearLibTerminal uses config strings to set itself up, so we build two of those, one for window properties, and one for font properties, and then apply to the terminial window using the Set method. Our config strings, respectivley, look like this after we&amp;rsquo;ve created them:
window: size=100x35,title=BearRogue font: fonts/UbuntuMono.ttf, size=24 You can read more about BearLibTerminals configuration strings here
Finally, we use the Set method to apply our config strings, and then we clear the terminal, making sure there is nothing displayed.
Now that we have initialized and configured our terminal window, its time to actually display it, along with some text! We&amp;rsquo;re going to do this in our main method, which is where our game loop will live for the time being. Our game loop for now is going to be very simple, its just going to check if the user has closed the window. If not, it will keep itself open.
func main() { blt.Print(1, 1, &amp;#34;Hello, world!&amp;#34;) blt.Refresh() for blt.Read() != blt.TK_CLOSE { // Do nothing here for now  } // If the user hit the close button, close the window and exit  blt.Close() } I&amp;rsquo;ve introduced a few new BearLibTerminal functions here. First is Print(), which will print the text we specify to the terminal, at the (x, y) coordinates provided. In this case, it prints &amp;ldquo;Hello, World!&amp;rdquo; to the coordinates (1, 1), which is the top left corner of the window. Next is Refresh() which effectively redraws the content of the terminal. No changes will be displayed until we call Refresh() again. Read() returns the next event from the event queue (which keeps track of user input). Hitting the close button on the window adds a TK_CLOSE event to the event queue, which, when we call Read(), will be returned. Finally, Close() will close the current window.
So, we are printing some text to the console with Print(), drawing that text to the console with Refresh(), endlessly looping until a TK_CLOSE event is pushed onto the event queue, and then using Close() to end the program. Easy!
At this point, if you run your program with:
go build bearrogue.go And run the resulting executable, you should see a window, with the title BearRogue, and the text &amp;ldquo;Hello, World!&amp;rdquo; displayed in the top left corner. Nice, we&amp;rsquo;re well on our way to having a functioning roguelike!
For a bonus, lets change the color of the text. Before we print the text &amp;ldquo;Hello, World!&amp;quot;, add this line, in your main function:
blt.Color(blt.ColorFromName(&amp;#34;darker green&amp;#34;)) The Color() function will change the color of all output to the terminal, until it is changed again. So, this will make our &amp;ldquo;Hello, World!&amp;rdquo; print out in a dark shade of green. BearLibTerminal is quite flexible in color names, but I&amp;rsquo;ll let you experiment with that, and read the specifics here.
So, now we&amp;rsquo;ve got a colorful message, but wouldn&amp;rsquo;t it be nice if it was perfectly centered on the screen? Lets add a function to print out centered text:
func printCenteredText(text string) { x := WindowSizeX / 2 - (len(text) / 2) y := WindowSizeY / 2 blt.Print(x, y, text) } Basically, we get the center point of the window (WindowSizeX / 2, WindowSizeY / 2), and then half the width of the text to print (len(text)). If we didn&amp;rsquo;t get half the width of the text, our text would print off center to the right, as it would start printing from the center point, not the center of the text. To use our new function, simply replace the Print() call in main with:
printCenteredText(&amp;#34;Hello, World&amp;#34;) Now, running our program again should yield a cliched, dark green message, perfectly centered in our terminal window!
To recap, this week we installed Go, installed BearLibTerminal, and set up a small Go program that creates a BearLibTerminal window, and prints a colored, centered, &amp;ldquo;Hello, World&amp;rdquo; message. Not too shabby. If you want to view the entire code for this week, you can find it under the Week 0 release on my repo. I&amp;rsquo;ll see you next week where we&amp;rsquo;ll be setting up the basics of our game! Happy developing!
This way to Part 2
]]></content:encoded>
    </item>
  </channel>
</rss>
